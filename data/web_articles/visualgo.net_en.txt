

Profile
Training
Tests
Log Out
VisuAlgo.net/en
visualising data structures and algorithms through animation
Featured story: Visualizing Algorithms with a Click
Featured blog: Digitisingas manystatic Computer Science textbooks examples into equivalent VisuAlgo animation
VisuAlgo project continues to be funded by Optiver (started mid 2023, to continue to mid 2025 and possibly beyond).The focus this AY24/25 is to make VisuAlgo much more mobile-friendly and to improve the online quiz capabilities.
Do You Know?Next Random Tip
VisuAlgo is a trilingual site. Try visiting the other versions of VisuAlgo other than the defaultEnglish version, e.g.,ChineseorIndonesian. Users can see thetranslation statisticsfor these three pages. We aim to make all three has near 100% translation rate. Unfortunately the translation progress with other languages are too far behind and they are thus redirected to English.
In VisuAlgo, you can useyour own inputfor any algorithm instead of using only the provided sample inputs. This is one of the key feature of VisuAlgo. Try the graph drawing feature in these 9 graph-related visualizations:Graph DS,DFS/BFS,MST,SSSP,Max Flow,Matching,MVC,Steiner Tree, andTSP. You can also click tag'graph'in any of these 9 graph-related visualization boxes or type in'graph'in the search box.
Here are some of the newer visualization features: ability to show two visualization scales (1.0x and 0.5x), the zoom-out scale is used to show operations of a slightly bigger test cases,/list(the linked list are no longer automatically re-layout for most cases to strengthen the O(1) impression of almost all Linked List operations).
Breaking news [Fri, 09 Jun 23]: VisuAlgo project is funded byOptiverstarting today. We now open VisuAlgo account registration to every Computer Science students/teachers worldwide. Go to thelogin pageand follow the on-screen instructions to create a new VisuAlgo account (no longer restricted to 'nus.edu'-related emails).
To compare 2 related algorithms, e.g.,Kruskal's vs Prim'son the same graph, or 2 related operations of the same data structure, e.g., visualizingBinary (Max) Heapas a Binary Tree or as a Compact Array, open 2 VisuAlgo pages in 2 windows and juxtapose them. Clickhereto see the screenshot. This juxtaposition technique can be used anytime you want to compare two similar data structures or algorithms.
You can visualize the recursion tree (or DAG, if there are overlapping subproblems and Dynamic Programming (DP) is applicable) ofANYvalidrecursive functionthat can be written in JavaScript. Clickhereto see the screenshot. Obviously do not try visualizing recursion with a gigantic recursion tree as doing so will crash your own web browser/computer.
VisuAlgo loads fast for first time visitors (we use Cloudflare global CDN), but it loads 'almost instantly' for returning visitors as we also cache lots of static content of VisuAlgo :). So, do not use incognito or private browsing mode to keep the cache. Moreover, for NUS students with VisuAlgo accounts, we will load VisuAlgo according to your preferences/class setup after youlogin.
Each visualization page has an 'e-Lecture Mode' that is accessible from that page's top right corner. This mode is automatically shown to first time (or non logged-in) visitors to showcase the data structure or algorithm being visualized. The quality of e-Lecture mode for many visualization pages have reached the lecture standard of algorithm classes in National University of Singapore :).
Please check the newest features of VisuAlgo: 1). User accounts system for NUS students and verified CS lecturers worldwide (and also read the latest Privacy Policy popup at the bottom right corner), 2). More mobile-friendly setup, 3). More polished e-Lecture notes to reach "NUS standard", and 4). Trilingual capability (/en, /zh, or /id).
VisuAlgo has two main components: The 24 visualization pages and their associated Online Quiz component (more questions are currently being added into the question bank). We do not script any of the questions in Online Quiz :O and all answers will be graded almost instantly :). You can this online quiz system by clicking the 'Training' button on the visualization module.
Click to ViewArrayTraining✍cs1010it5003cs2040cs3230cs3233
Click to ViewSortingTraining✍arrayalgorithmbubbleselectinsertselectioninsertionmergequickrandomized quickcountingradixsortcs1010it5003cs2040cs3230listdata structuresorting
Click to ViewBitmaskTraining✍bit manipulationsetcs3233arraylistdsdata structurebitmask
Click to ViewLinked ListTraining✍stackqueuedoublydequeit5003cs2040arraydsdata structurelinked
Click to ViewBinary HeapTraining✍priority queuerecursiveit5003cs2040recursiondsdata structurebinaryheap
Click to ViewHash TableTraining✍open addressinglinearquadraticprobingit5003cs2040dsdata structure
Click to ViewBinary Search TreeTraining✍adelson velskii landissettableavlit5003cs2040recursionrecursivedsdata structuresetbstbinarysearchtreepriorityqueue
Click to ViewGraph StructuresTraining✍treecompletebipartitedagit5003cs2040graphdsdata structure
Click to ViewUnion-Find DSTraining✍path compressiondisjointsetdata structureunion by rankcs2040cs3233arraytreefindds
Click to ViewFenwick TreeTraining✍binary indexed treebitdynamicfenwickrangesumpointupdatecs3233binarydsdata structure
Click to ViewSegment TreeTraining✍dynamicrangesumminmaxcs3233segmenttreedsdata structure
Click to ViewRecursion Tree/DAGTraining✍dynamic programmingdpgenericcs1010it5003cs2040cs3233cs4234recursivealgorithmrecursiontreedag
Click to ViewGraph TraversalTraining✍bfsdfsit5003cs2040bipartitescccut vertexarticulation pointbridgecs2020graphalgorithm
Click to ViewMin Spanning TreeTraining✍mstprimkruskalgraphminspanningcs2040treealgorithm
Click to ViewSS Shortest PathsTraining✍ssspsingle-sourcebfsdijkstrabellman fordit5003cs2040single sourceshortest pathgraphalgorithm
Click to ViewCycle FindingTraining✍floydtortoise-haremathcs3233algorithm
Click to ViewSuffix TreeTraining✍stringmatchinglrslcscs3233suffixtreedsdata structure
Click to ViewSuffix ArrayTraining✍lcpcs3233matchinglrslcssuffixarraystringdsdata structure
Click to ViewGeometry (Polygon)Training✍convexcutwindingconcavecs3233computationalgeometryalgorithm
Click to ViewConvex HullTraining✍andrewmonotone chaingrahamscanjarvismarchcs3233computationalgeometryalgorithm
Click to ViewNetwork FlowTraining✍max flowedmonds karpmin cutdinicford fulkersongraphcs3233cs4234algorithm
Click to ViewGraph MatchingTraining✍augmenting pathbipartitegraphcs3233cs4234matchingalgorithm
Click to ViewMin Vertex CoverTraining✍np-hardgraphbipartitetreetreedpbipartitematchingmax flowcs3233cs4234
Click to ViewSteiner TreeTraining✍np-hardgraphmstcs4234
Click to ViewTraveling Salesperson ProblemTraining✍np-hardgraphdpmstcs3233cs4234
Click to ViewNP-complete Reductions✍cs3230cs4234
Reload screen or rotate device for a pathway suiting your device orientation
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
VisuAlgo.net/en
visualising data structures and algorithms through animation
Featured story: Visualizing Algorithms with a Click
Featured blog: Digitisingas manystatic Computer Science textbooks examples into equivalent VisuAlgo animation
VisuAlgo project continues to be funded by Optiver (started mid 2023, to continue to mid 2025 and possibly beyond).The focus this AY24/25 is to make VisuAlgo much more mobile-friendly and to improve the online quiz capabilities.
Do You Know?Next Random Tip
VisuAlgo is a trilingual site. Try visiting the other versions of VisuAlgo other than the defaultEnglish version, e.g.,ChineseorIndonesian. Users can see thetranslation statisticsfor these three pages. We aim to make all three has near 100% translation rate. Unfortunately the translation progress with other languages are too far behind and they are thus redirected to English.
In VisuAlgo, you can useyour own inputfor any algorithm instead of using only the provided sample inputs. This is one of the key feature of VisuAlgo. Try the graph drawing feature in these 9 graph-related visualizations:Graph DS,DFS/BFS,MST,SSSP,Max Flow,Matching,MVC,Steiner Tree, andTSP. You can also click tag'graph'in any of these 9 graph-related visualization boxes or type in'graph'in the search box.
Here are some of the newer visualization features: ability to show two visualization scales (1.0x and 0.5x), the zoom-out scale is used to show operations of a slightly bigger test cases,/list(the linked list are no longer automatically re-layout for most cases to strengthen the O(1) impression of almost all Linked List operations).
Breaking news [Fri, 09 Jun 23]: VisuAlgo project is funded byOptiverstarting today. We now open VisuAlgo account registration to every Computer Science students/teachers worldwide. Go to thelogin pageand follow the on-screen instructions to create a new VisuAlgo account (no longer restricted to 'nus.edu'-related emails).
To compare 2 related algorithms, e.g.,Kruskal's vs Prim'son the same graph, or 2 related operations of the same data structure, e.g., visualizingBinary (Max) Heapas a Binary Tree or as a Compact Array, open 2 VisuAlgo pages in 2 windows and juxtapose them. Clickhereto see the screenshot. This juxtaposition technique can be used anytime you want to compare two similar data structures or algorithms.
You can visualize the recursion tree (or DAG, if there are overlapping subproblems and Dynamic Programming (DP) is applicable) ofANYvalidrecursive functionthat can be written in JavaScript. Clickhereto see the screenshot. Obviously do not try visualizing recursion with a gigantic recursion tree as doing so will crash your own web browser/computer.
VisuAlgo loads fast for first time visitors (we use Cloudflare global CDN), but it loads 'almost instantly' for returning visitors as we also cache lots of static content of VisuAlgo :). So, do not use incognito or private browsing mode to keep the cache. Moreover, for NUS students with VisuAlgo accounts, we will load VisuAlgo according to your preferences/class setup after youlogin.
Each visualization page has an 'e-Lecture Mode' that is accessible from that page's top right corner. This mode is automatically shown to first time (or non logged-in) visitors to showcase the data structure or algorithm being visualized. The quality of e-Lecture mode for many visualization pages have reached the lecture standard of algorithm classes in National University of Singapore :).
Please check the newest features of VisuAlgo: 1). User accounts system for NUS students and verified CS lecturers worldwide (and also read the latest Privacy Policy popup at the bottom right corner), 2). More mobile-friendly setup, 3). More polished e-Lecture notes to reach "NUS standard", and 4). Trilingual capability (/en, /zh, or /id).
VisuAlgo has two main components: The 24 visualization pages and their associated Online Quiz component (more questions are currently being added into the question bank). We do not script any of the questions in Online Quiz :O and all answers will be graded almost instantly :). You can this online quiz system by clicking the 'Training' button on the visualization module.
Click to ViewArrayTraining✍cs1010it5003cs2040cs3230cs3233
Click to ViewSortingTraining✍arrayalgorithmbubbleselectinsertselectioninsertionmergequickrandomized quickcountingradixsortcs1010it5003cs2040cs3230listdata structuresorting
Click to ViewBitmaskTraining✍bit manipulationsetcs3233arraylistdsdata structurebitmask
Click to ViewLinked ListTraining✍stackqueuedoublydequeit5003cs2040arraydsdata structurelinked
Click to ViewBinary HeapTraining✍priority queuerecursiveit5003cs2040recursiondsdata structurebinaryheap
Click to ViewHash TableTraining✍open addressinglinearquadraticprobingit5003cs2040dsdata structure
Click to ViewBinary Search TreeTraining✍adelson velskii landissettableavlit5003cs2040recursionrecursivedsdata structuresetbstbinarysearchtreepriorityqueue
Click to ViewGraph StructuresTraining✍treecompletebipartitedagit5003cs2040graphdsdata structure
Click to ViewUnion-Find DSTraining✍path compressiondisjointsetdata structureunion by rankcs2040cs3233arraytreefindds
Click to ViewFenwick TreeTraining✍binary indexed treebitdynamicfenwickrangesumpointupdatecs3233binarydsdata structure
Click to ViewSegment TreeTraining✍dynamicrangesumminmaxcs3233segmenttreedsdata structure
Click to ViewRecursion Tree/DAGTraining✍dynamic programmingdpgenericcs1010it5003cs2040cs3233cs4234recursivealgorithmrecursiontreedag
Click to ViewGraph TraversalTraining✍bfsdfsit5003cs2040bipartitescccut vertexarticulation pointbridgecs2020graphalgorithm
Click to ViewMin Spanning TreeTraining✍mstprimkruskalgraphminspanningcs2040treealgorithm
Click to ViewSS Shortest PathsTraining✍ssspsingle-sourcebfsdijkstrabellman fordit5003cs2040single sourceshortest pathgraphalgorithm
Click to ViewCycle FindingTraining✍floydtortoise-haremathcs3233algorithm
Click to ViewSuffix TreeTraining✍stringmatchinglrslcscs3233suffixtreedsdata structure
Click to ViewSuffix ArrayTraining✍lcpcs3233matchinglrslcssuffixarraystringdsdata structure
Click to ViewGeometry (Polygon)Training✍convexcutwindingconcavecs3233computationalgeometryalgorithm
Click to ViewConvex HullTraining✍andrewmonotone chaingrahamscanjarvismarchcs3233computationalgeometryalgorithm
Click to ViewNetwork FlowTraining✍max flowedmonds karpmin cutdinicford fulkersongraphcs3233cs4234algorithm
Click to ViewGraph MatchingTraining✍augmenting pathbipartitegraphcs3233cs4234matchingalgorithm
Click to ViewMin Vertex CoverTraining✍np-hardgraphbipartitetreetreedpbipartitematchingmax flowcs3233cs4234
Click to ViewSteiner TreeTraining✍np-hardgraphmstcs4234
Click to ViewTraveling Salesperson ProblemTraining✍np-hardgraphdpmstcs3233cs4234
Click to ViewNP-complete Reductions✍cs3230cs4234
Reload screen or rotate device for a pathway suiting your device orientation
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
VisuAlgo Account Login
Breaking news [Fri, 09 Jun 23]:
Thanks to the generous fund from Optiver,
we can now scale-up VisuAlgo server from just NUS-wide to world-wide.
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
VisuAlgo Account Login
Breaking news [Fri, 09 Jun 23]:
Thanks to the generous fund from Optiver,
we can now scale-up VisuAlgo server from just NUS-wide to world-wide.
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
Loading... Please Wait.
You can select any subset of modules, difficulty level, number of questions, and time limit.
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
VisuAlgo Account Login
Breaking news [Fri, 09 Jun 23]:
Thanks to the generous fund from Optiver,
we can now scale-up VisuAlgo server from just NUS-wide to world-wide.
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
VisuAlgo Account Login
Breaking news [Fri, 09 Jun 23]:
Thanks to the generous fund from Optiver,
we can now scale-up VisuAlgo server from just NUS-wide to world-wide.
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
VisuAlgo.net/zh
通过动画可视化数据结构和算法
Featured story: Visualizing Algorithms with a Click
Featured blog: Digitisingas manystatic Computer Science textbooks examples into equivalent VisuAlgo animation
VisuAlgo project continues to be funded by Optiver (started mid 2023, to continue to mid 2025 and possibly beyond).The focus this AY24/25 is to make VisuAlgo much more mobile-friendly and to improve the online quiz capabilities.
你知道吗？下一个随机提示
VisuAlgo是一个三语言网站。尝试访问除默认的英文版之外的其他VisuAlgo版本，例如中文版或印尼版。用户可以查看这三个页面的翻译统计。我们的目标是使这三个页面的翻译率接近100%。不幸的是，其他语言的翻译进度远远落后，因此它们被重定向到英文版。
在VisuAlgo中，您可以使用自己的输入进行任何算法，而不只是样本输入。 这是VisuAlgo的一大特性。在这6个图形相关的可视化中尝试图形绘制功能：图形DS，DFS / BFS，MST，SSSP，最大流量和匹配。 您也可以在这6个图表相关的可视化对象框中点击标签'graph'，或在搜索框中输入'graph'
这里是一些新的可视化功能：能够显示两个可视化比例（1.0x和0.5x），缩小比例用于显示稍大的测试用例的操作，/list（大多数情况下，链表不再自动重新布局，以加强几乎所有链表操作的O(1)印象）。
重大新闻 [Fri, 09 Jun 23]: VisuAlgo 项目从今天开始由Optiver赞助。我们现在向全球的计算机科学学生/教师开放 VisuAlgo 账户注册。请访问登录页面并按照屏幕上的指示创建一个新的 VisuAlgo 账户（不再限制于 'nus.edu' 相关的电子邮件）。
为了比较2个相关算法， 例如在同一个图表上跑Kruskal和Prim，或在同一种数据结构上进行两个相关的操作（如最大堆作为二叉树和紧凑数组的不同格式），打开2 个VisuAlgo窗口，并列他们。 点击这里查看截图。
您可以可视化用JavaScript编写的任何有效递归函数的递归树（或DAG，如果存在重叠的子问题和动态规划（DP））。 点击这里查看截图。显然，不要尝试使用巨大的递归树来可视化递归，因为这样做会使您自己的 Web 浏览器/计算机崩溃。
VisuAlgo第一次加载很快（我们用了CloudFlare的全球CDN），但第二次加载会更快，因为我们缓存了大量的静态内容 :)（所以请不要使用隐身浏览模式或隐私浏览模式，以让缓存发挥作用）。对于NUS的学生，在登陆后VisuAlgo将会根据你的偏好/课程设定加载。
每个可视化页面都有一个“电子讲座模式”，可以从页面右上角访问。该模式会自动显示给首次访问（或未登录）的访问者，以展示正在可视化的数据结构或算法。许多可视化页面的电子讲座模式已经达到了新加坡国立大学算法课程的讲座标准 :)。
请查看 VisuAlgo 的最新功能：1). 针对新加坡国立大学的学生和全球认证的计算机科学讲师的用户账户系统（并阅读右下角的最新隐私政策弹窗），2). 更加适合移动设备的设置，3). 更加完善的电子讲义，达到 "新加坡国立大学标准"，以及 4). 三语能力（/en，/zh，或 /id）。
VisuAlgo主要有两个部分：24个可视化页面及其相关的在线测验组件（我们正在向题库中添加更多的问题）。我们不会在在线测验中编写任何问题:O，所有的答案都将几乎立即被评分:)。您可以通过点击可视化模块上的 '培训' 按钮来使用这个在线测验系统。
Click to ViewArray训练✍cs1010it5003cs2040cs3230cs3233
Click to View排序训练✍数组算法冒泡选择插入选择插入归并快速随机快速计数基排序cs1010it5003cs2040cs3230列表数据结构排序
Click to View位掩码训练✍位操作设置cs3233数组列表动态规划数据结构位掩码
Click to View链表训练✍都列队列双向双端队列it5003cs2040数组动态规划数据结构链接
Click to View二叉堆训练✍优先队列递归it5003cs2040递归动态规划数据结构二进制堆
Click to View哈希表训练✍开放地址线性的二次探测it5003cs2040动态规划数据结构
Click to View二叉搜索树训练✍avl树设置表avl树it5003cs2040递归递归动态规划数据结构设置二叉排序树二进制找树优先队列
Click to View图结构训练✍树完成二分图有向无环图it5003cs2040图动态规划数据结构
Click to View并查集训练✍路径压缩不相交设置数据结构按秩合并cs2040cs3233数组树找动态规划
Click to View树状数组训练✍二叉索树字节动态的芬威克范围，域求和点更新cs3233二进制动态规划数据结构
Click to View线段树训练✍动态的范围，域求和最小最大cs3233段树动态规划数据结构
Click to View递归树/有向无环图训练✍动态规划动态规划范型cs1010it5003cs2040cs3233cs4234递归算法递归树有向无环图
Click to View图遍历训练✍广度优先搜索深度优先搜索it5003cs2040二分图强连通分量切割顶点节点立交桥cs2020图算法
Click to View最小生成树训练✍多生成树prim算法(kruskal算法)图最小搅拌cs2040树算法
Click to View单源最短路径训练✍sssp单源广度优先搜索dijkstrabellman fordit5003cs2040单源最短路径图算法
Click to View循环查找训练✍弗洛伊德龟兔赛跑数学cs3233算法
Click to View后缀树训练✍字符串匹配似然比选择最长公共子序列cs3233后缀树动态规划数据结构
Click to View后缀数组训练✍最长公共前缀cs3233匹配似然比选择最长公共子序列后缀数组字符串动态规划数据结构
Click to View计算几何训练✍转换切除弯曲凹cs3233计算几何算法
Click to View凸体船体训练✍andrew算法单调链葛立恒查阅jarvis步进算法游行，遍历cs3233计算几何算法
葛立恒
Click to View网络流训练✍最大流edmonds karp最小割dinicford fulkerson图cs3233cs4234算法
Click to View二分匹配训练✍增强路径二分图图cs3233cs4234匹配算法
Click to View最小顶点覆盖训练✍np-hard图二分图树树动态规划二分图匹配最大流cs3233cs4234
Click to ViewSteiner Tree训练✍np-hard图多生成树cs4234
Click to View旅行商问题训练✍np-hard图动态规划多生成树cs3233cs4234
Click to ViewNP-complete Reductions✍cs3230cs4234
Reload screen or rotate device for a pathway suiting your device orientation
VisuAlgo最初由副教授Steven Halim于2011年构思，旨在通过提供自学、互动式学习平台，帮助学生更深入地理解数据结构和算法。
VisuAlgo涵盖了Steven Halim博士与Felix Halim博士、Suhendry Effendy博士合著的书《竞技编程》中讨论的许多高级算法。即使过去十年，VisuAlgo仍然是可视化和动画化这些复杂算法的独家平台。
虽然VisuAlgo主要面向新加坡国立大学（NUS）的学生，包括各种数据结构和算法课程（例如CS1010/等价课程，CS2040/等价课程（包括IT5003），CS3230，CS3233和CS4234），但它也是全球好奇心的宝贵资源，促进在线学习。
最初，VisuAlgo并不适用于智能手机等小触摸屏，因为复杂的算法可视化需要大量的像素空间和点击拖动交互。为了获得最佳用户体验，建议使用最低分辨率为1366x768的屏幕。然而，自2022年4月以来，VisuAlgo的移动（精简）版本已经推出，使得在智能手机屏幕上使用VisuAlgo的部分功能成为可能。
VisuAlgo仍然在不断发展中，正在开发更复杂的可视化。目前，该平台拥有24个可视化模块。
VisuAlgo配备了内置的问题生成器和答案验证器，其“在线测验系统”使学生能够测试他们对基本数据结构和算法的理解。问题根据特定规则随机生成，并且学生提交答案后会自动得到评分。随着越来越多的计算机科学教师在全球范围内采用这种在线测验系统，它可以有效地消除许多大学标准计算机科学考试中手工基本数据结构和算法问题。通过给通过在线测验的学生分配一个小但非零的权重，计算机科学教师可以显著提高学生对这些基本概念的掌握程度，因为他们可以在参加在线测验之前立即验证几乎无限数量的练习题。每个VisuAlgo可视化模块现在都包含自己的在线测验组件。
VisuAlgo已经被翻译成三种主要语言：英语、中文和印尼语。此外，我们还用各种语言撰写了关于VisuAlgo的公开笔记，包括印尼语、韩语、越南语和泰语：
项目领导和顾问（2011年7月至今）Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
本科生研究人员 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
最后一年项目/ UROP学生 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
本科生研究人员 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
最后一年项目/ UROP学生 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
本科生研究人员 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
最后一年项目/ UROP学生 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
致谢NUS教学与学习发展中心（CDTL）授予拨款以启动这个项目。在2023/24学年，Optiver的慷慨捐赠将被用来进一步开发 VisuAlgo。
VisuAlgo慷慨地向全球计算机科学界提供免费服务。如果您喜欢VisuAlgo，我们恳请您向其他计算机科学学生和教师宣传它的存在。您可以通过社交媒体平台（如Facebook、YouTube、Instagram、TikTok、Twitter等）、课程网页、博客评论、电子邮件等方式分享VisuAlgo。
数据结构与算法（DSA）的学生和教师可以直接在课堂上使用本网站。如果您从本网站截取屏幕截图或视频，可以在其他地方使用，但请引用本网站的URL（https://visualgo.net）和/或下面的出版物列表作为参考。但请不要下载VisuAlgo的客户端文件并将其托管在您的网站上，因为这构成了抄袭行为。目前，我们不允许他人分叉此项目或创建VisuAlgo的变体。个人使用离线副本的客户端VisuAlgo是可以接受的。
请注意，VisuAlgo的在线测验组件具有重要的服务器端元素，保存服务器端脚本和数据库并不容易。目前，普通公众只能通过“培训模式”访问在线测验系统。“测试模式”提供了一个更受控制的环境，用于在新加坡国立大学的真实考试中使用随机生成的问题和自动验证。
出版物列表
这项工作曾在2012年国际大学生程序设计竞赛（波兰，华沙）的CLI研讨会上和2012年国际信息学奥林匹克竞赛（意大利，锡尔米奥内-蒙蒂基亚里）的IOI会议上展示过。您可以点击此链接阅读我们2012年关于该系统的论文（当时还没有称为VisuAlgo），以及此链接阅读2015年的简短更新（将VisuAlgo与之前的项目关联起来）。
错误报告或新功能请求
VisuAlgo并不是一个完成的项目。Steven Halim副教授仍在积极改进VisuAlgo。如果您在使用VisuAlgo时发现任何可视化页面/在线测验工具中的错误，或者您想要请求新功能，请联系Steven Halim副教授。他的联系方式是将他的名字连接起来，然后加上gmail dot com。
版本 1.2 (更新于2023年8月18日星期五)。
自2023年8月18日（星期五）起，我们不再使用 Google Analytics。因此，我们现在使用的所有 cookies 仅用于此网站的运营。即使是首次访问的用户，烦人的 cookie 同意弹窗现在也已关闭。
自2023年6月7日（星期五）起，由于 Optiver 的慷慨捐赠，全世界的任何人都可以自行创建一个 VisuAlgo 账户，以存储一些自定义设置（例如，布局模式，默认语言，播放速度等）。
此外，对于 NUS 学生，通过使用 VisuAlgo 账户（一个 NUS 官方电子邮件地址，课堂名册中的学生姓名，以及在服务器端加密的密码 - 不存储其他个人数据），您同意您的课程讲师跟踪您的电子讲义阅读和在线测验培训进度，这是顺利进行课程所必需的。您的 VisuAlgo 账户也将用于参加 NUS 官方的 VisuAlgo 在线测验，因此，将您的账户凭据传递给他人代您进行在线测验构成学术违规。课程结束后，您的用户账户将被清除，除非您选择保留您的账户（OPT-IN）。访问完整的 VisuAlgo 数据库（包含加密密码）的权限仅限于 Halim 教授本人。
对于全球其他已经给 Steven 写过信的 CS 讲师，需要一个 VisuAlgo 账户（您的（非 NUS）电子邮件地址，您可以使用任何显示名称，以及加密密码）来区分您的在线凭据与世界其他地方。您的账户将具有 CS 讲师特定的功能，即能够查看隐藏的幻灯片，这些幻灯片包含了在隐藏幻灯片之前的幻灯片中提出的问题的（有趣的）答案。您还可以访问 VisuAlgo 在线测验的 Hard 设置。您可以自由地使用这些材料来增强您的数据结构和算法课程。请注意，未来可能会有其他 CS 讲师特定的功能。
对于任何拥有 VisuAlgo 账户的人，如果您希望不再与 VisuAlgo 工具有关联，您可以自行删除您的账户。

Profile
Training
Tests
Log Out
VisuAlgo.net/id
visualisasi struktur data dan algoritma dengan animasi (Indonesian)
Featured story: Visualizing Algorithms with a Click
Featured blog: Digitisingas manystatic Computer Science textbooks examples into equivalent VisuAlgo animation
VisuAlgo project continues to be funded by Optiver (started mid 2023, to continue to mid 2025 and possibly beyond).The focus this AY24/25 is to make VisuAlgo much more mobile-friendly and to improve the online quiz capabilities.
Tahukah Anda?Tips Acak Berikutnya
VisuAlgo adalah situs tiga bahasa. Silahkan kunjungi versi-versi lain dari VisuAlgo selainversi Inggris, yaituMandarinorIndonesia.Pengunjung dapat melihatstatistik penerjemahandari ketiga halaman-halaman ini (kami berjuang untuk membuat ketiganya mendekati 100% segera). Sayang sekali kemajuan penerjemahan dengan bahasa-bahasa lain terlalu tertinggal dibelakang dan mereka jadi dialihkan ke Bahasa Inggris lagi.
Dalam VisuAlgo, anda bisa memasukkaninput anda sendiriuntuk algoritma apapun daripada hanya menggunkan masukan-masukan contoh dari kami. Cobalah fitur penggambaran input graf di 9 visualisasi yang berkaitan dengan graf:Struktur Data Graf,DFS/BFS,Pohon Perentang Terkecil,Jarak Terpendek,Aliran Maksimum,Pencocokan Graf,MVC,Pohon Steiner, danTSP.Anda juga bisa meng-klik tag'graf'di salah satu dari 9 visualisasi graf atau ketik'graf'di kotak pencarian.
Berikut adalah beberapa fitur visualisasi terbaru: kemampuan untuk menampilkan dua skala visualisasi (1,0x dan 0,5x), skala zoom-out digunakan untuk menampilkan operasi dari kasus uji yang sedikit lebih besar,/list(daftar yang tertaut tidak lagi secara otomatis disusun ulang untuk sebagian besar kasus untuk memperkuat kesan O(1) dari hampir semua operasi Daftar Taut).
Berita terbaru [Jumat, 09 Juni 23]: Proyek VisuAlgo didanai olehOptivermulai hari ini. Kami kini membuka pendaftaran akun VisuAlgo untuk semua mahasiswa/guru Ilmu Komputer di seluruh dunia. Kunjungihalaman logindan ikuti petunjuk di layar untuk membuat akun VisuAlgo baru (tidak lagi terbatas pada email terkait 'nus.edu').
Untuk membandingkan 2 algoritma relevan sepertiKruskal dengan Primdi graf yang sama, buka 2 halaman VisuAlgo di 2 jendela dan taruh mereka bersebelahan. Klikdisiniuntuk melihatscreenshotnya. Teknik juktaposisi ini bisa dipakai kapan saja jika anda mau membandingkan dua struktur-struktur data atau algoritma-algoritma yang mirip.
Anda dapat memvisualisasikan pohon rekursi (atau DAG, jika ada sub-problem yang berulang dan Pemrograman Dinamis (DP) dapat digunakan) darifungsi rekursiapapunyang bisa ditulis secara legal di JavaScript. Klikdisiniuntuk melihatscreenshotnya. Tentu saja jangan coba visualisasikan rekursi dengan pohon rekursi raksaksa karena hal itu dapat menyebabkan komputer ataubrowserweb andacrash.
VisuAlgo di-loadcepat untuk pengunjung pertama (kami menggunakan CDN global dari Cloudflare), tetapi dapat di-load 'hampir instan' untuk pengunjung setia karena kami men-cachebanyak dari konten statis dari VisuAlgo :). Jadi, jangan pakai mode incognito atau browsing privat supaya cache file-file VisuAlgo tetap tersimpan. Terlebih lagi, untuk murid-murid NUS dengan akun-akun VisuAlgo, kami akan me-loadVisuAlgo sesuai dengan preferensi anda/setingan kelas setelah andalogin.
Setiap halaman visualisasi memiliki 'Mode Kuliah Maya' yang dapat diakses dari sisi kanan atas halaman tersebut. Mode ini ditampilkan secara otomatis kepada pengunjung pertama (atau yang tidak logged-in) untuk menunjukkan struktur data atau algoritma yang sedang divisualisasikan. Kualitas dari Mode Kuliah Maya akan perlahan-lahan dibuat mencapai standar kuliah dari kelas-kelas algoritma di National University of Singapore :).
Silahkan mencoba fitur-fitur terbaru dari VisuAlgo: 1). Akun-akun pengguna untuk murid-murid NUS saja (dan juga baca boks Panduan Privasi di sisi kanan bawah), 2). Setup yang lebihmobile-friendly3). Mode kuliah maya yang lebih bagus untuk mencapai "standar NUS", dan 4). Kemampuan tiga-bahasa (/en, /zh, atau /id).
VisuAlgo mempunyai dua komponen utama: 24 halaman visualisasi dan komponen Kuis Online (lebih banyak pertanyaan saat ini sedang ditambahkan ke dalam bank soal). Kami tidak membuat skrip pertanyaan-pertanyaan dalam Kuis Online :O dan semua jawaban-jawaban akan dievaluasi hampir seketika itu juga :). Anda bisa mencoba sistem Kuis Online dengan mengklik tombol 'Latihan' di modul visualisasi.
Click to ViewArrayLatihan✍cs1010it5003cs2040cs3230cs3233
Click to ViewPengurutanLatihan✍larikalgoritmagelembungpilihsisipkanpemilihanpenyisipangabungkancepatcepat teracakpenghitunganradixmengurutkancs1010it5003cs2040cs3230senaraistruktur datapengurutan
Click to ViewMasker BitLatihan✍manipulasi bithimpunancs3233lariksenaraidsstruktur datamasker bit
Click to ViewSenarai BerantaiLatihan✍tumpukanantreangandadequeit5003cs2040larikdsstruktur databerantai
Click to ViewTimbunan BinerLatihan✍antrean berprioritasrekursifit5003cs2040rekursidsstruktur databinertimbunan
Click to ViewTabel HashLatihan✍pengalamatan terbukalinearkuadratikhash gandait5003cs2040dsstruktur data
Click to ViewPohon Biner TerurutLatihan✍adelson velskii landishimpunantabelavlit5003cs2040rekursirekursifdsstruktur datahimpunanbstbinercaripohonprioritasantrean
Click to ViewStruktur Data GrafLatihan✍pohonlengkapbipartitdagit5003cs2040grafdsstruktur data
Click to ViewHimpunan LepasLatihan✍kompresi pathlepashimpunanstruktur datapenggabungan berdasarkan peringkatcs2040cs3233larikpohoncarids
Click to ViewPohon FenwickLatihan✍pohon indeks binerbitdinamisfenwickjarakjumlahtitikubahcs3233binerdsstruktur data
Click to ViewPohon SegmenLatihan✍dinamisjarakjumlahminimummaksimumcs3233segmenpohondsstruktur data
Click to ViewPohon/DAG RekursiLatihan✍pemrograman dinamisdpgenerikcs1010it5003cs2040cs3233cs4234rekursifalgoritmarekursipohondag
Click to ViewPenjelajahan GrafLatihan✍bfsdfsit5003cs2040bipartitsccsimpul pemotongtitik artikulasijembatancs2020grafalgoritma
Click to ViewPohon Rentangan MinimumLatihan✍mstprimkruskalgrafminimumrentangcs2040pohonalgoritma
Click to ViewJalur-Jalur Terpendek STLatihan✍ssspsatu-sumberbfsdijkstrabellman fordit5003cs2040satu sumberjarak terpendekgrafalgoritma
Click to ViewPencarian SiklusLatihan✍floydkura-kura-kelincimatematikacs3233algoritma
Click to ViewPohon AkhiranLatihan✍stringpencocokanlrslcscs3233akhiranpohondsstruktur data
Click to ViewLarik AkhiranLatihan✍lcpcs3233pencocokanlrslcsakhiranlarikstringdsstruktur data
Click to ViewGeometri (Poligon)Latihan✍cembungpotongberlikucekungcs3233komputasionalgeometrialgoritma
Click to ViewHull CembungLatihan✍andrewrantai monotongrahamscanjarvismarchcs3233komputasionalgeometrialgoritma
Click to ViewJaringan AliranLatihan✍aliran terbesaredmonds karppotongan minimumdinicford fulkersongrafcs3233cs4234algoritma
Click to ViewPencocokan GrafLatihan✍augmenting pathbipartitgrafcs3233cs4234pencocokanalgoritma
Click to ViewMin Vertex CoverLatihan✍np-hardgrafbipartitpohonpohondpbipartitpencocokanaliran terbesarcs3233cs4234
Click to ViewSteiner TreeLatihan✍np-hardgrafmstcs4234
Click to ViewTraveling Salesperson ProblemLatihan✍np-hardgrafdpmstcs3233cs4234
Click to ViewNP-complete Reductions✍cs3230cs4234
Reload screen or rotate device for a pathway suiting your device orientation
VisuAlgo digagas pada tahun 2011 oleh Associate Professor Steven Halim sebagai alat untuk membantu murid-muridnya mengerti struktur-struktur data dan algoritma-algoritma, dengan memampukan mereka untuk mempelajari dasar-dasarnya secara otodidak dan dengan kecepatan mereka sendiri.
VisuAlgo mempunya banyak algoritma-algoritma tingkat lanjut yang dibahas didalam buku Dr. Steven Halim ('Competitive Programming', yang ditulis bersama adiknya Dr. Felix Halim dan temannya Dr. Suhendry Effendy) dan lebih lagi. Hari ini, beberapa dari visualisasi/animasi algoritma-algoritma tingkat lanjut ini hanya ditemukan di VisuAlgo.
Meskipun pada khususnya didesain untuk murid-murid National University of Singapore (NUS) yang mengambil berbagai kelas-kelas struktur data dan algoritma (contoh: CS1010/setara, CS2040/setara (termasuk IT5003), CS3230, CS3233, dan CS4234), sebagai pendukung pembelajaran online, kami berharap bahwa orang-orang di berbagai belahan dunia menemukan visualisasi-visualisasi di website ini berguna bagi mereka juga.
VisuAlgo tidak didesain untuk layar sentuh kecil (sepertismartphones) dari awalnya karena kami harus membuat banyak visualisasi-visualisasi algoritma kompleks yang membutuhkan banyakpixelsdan gestur klik-dan-tarik untuk interaksinya. Resolusi layar minimum untuk pengalaman pengguna yang lumayan adalah1366x768dan hanya halaman utama VisuAlgo yang secara relatif lebih ramah dengan layar kecil. Tetapi, kami sedang bereksperimen dengan versi mobil (kecil) dari VisuAlgo yang akan siap pada April 2022.
VisuAlgo adalah proyek yang sedang terus berlangsung dan visualisasi-visualisasi yang lebih kompleks sedang dibuat. Pada saat ini, platform ini mempunyai 24 modul visualisasi.
Perkembangan yang paling menarik adalah pembuatan pertanyaan otomatis (sistem kuisonline) yang bisa dipakai oleh murid-murid untuk menguji pengetahuan mereka tentang dasar struktur-struktur data dan algoritma-algoritma. Pertanyaan-pertanyaan dibuat secara acak dengan semacam rumus dan jawaban-jawaban murid-murid dinilai secara instan setelah dikirim ke server penilai kami. Sistem kuis online ini, saat sudah diadopsi oleh banyak dosen Ilmu Komputer diseluruh dunia, seharusnya bisa menghapuskan pertanyaan-pertanyaan dasar tentang struktur data dan algoritma dari ujian-ujian di banyak Universitas. Dengan memberikan bobot kecil (tapi tidak kosong) supaya murid-murid mengerjakan kuisonlineini, seorang dosen Ilmu Komputer dapat dengan signifikan meningkatkan penguasaan materi dari murid-muridnya tentang pertanyaan-pertanyaan dasar ini karena murid-murid mempunyai kesempatan untuk menjawab pertanyaan-pertanyaan ini yang bisa dinilai secara instan sebelum mereka mengambil kuisonlineyang resmi. Mode latihan saat ini mempunyai pertanyaan-pertanyaan untuk 12 modul visualisasi. Kami akan segera menambahkan pertanyaan-pertanyaan untuk 12 modul visualisasi yang lainnya sehingga setiap setiap modul visualisasi di VisuAlgo mempunyai komponen kuisonline.
Kami telah menerjemahkan halaman-halaman VisuALgo ke tiga bahasa-bahasa utama: Inggris, Mandarin, dan Indonesia. Saat ini, kami juga telah menulis catatan-catatan publik tentang VisuAlgo dalam berbagai bahasa, termasuk Bahasa Indonesia, Korea, Vietnam, dan Thai:
Pemimpin & Penasihat Proyek (Jul 2011-sekarang)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Murid-Murid S1 Peniliti 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Murid-Murid Proyek Tahun Terakhir/UROP 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Murid-Murid S1 Peniliti 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Murid-Murid Proyek Tahun Terakhir/UROP 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Murid-Murid S1 Peniliti 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Murid-Murid Proyek Tahun Terakhir/UROP 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
Ucapan Terima KasihProyek ini dimungkinkan karena Hibah Pengembangan Pengajaran dari NUS Centre for Development of Teaching and Learning (CDTL).
VisuAlgo bebas biaya untuk komunitas Ilmu Komputer di dunia. Jika anda menyukai VisuAlgo, satu-satunya "pembayaran" yang kami minta dari anda adalah agar andamenceritakan keberadaan VisuAlgo kepada murid-murid/dosen-dosen Ilmu Komputer. Anda dapat menceritakan tentang VisuAlgo melewati media sosial yang anda tahu lewat postingan Facebook/Twitter/Instagram/TikTok, situs mata kuliah, ulasan di blog, email-email, dsb.
Mahasiswa dan pengajar Struktur Data dan Algoritma (DSA) dipersilakan untuk menggunakan situs web ini langsung untuk kelas mereka. Jika Anda mengambil tangkapan layar atau video dari situs ini, Anda dapat menggunakannya di tempat lain, asalkan mencantumkan URL situs web ini (https://visualgo.net) dan/atau daftar publikasi di bawah sebagai referensi. Namun, harap hindari mengunduh file sisi-klien VisuAlgo dan menghostingnya di situs web Anda, karena ini dianggap sebagai plagiarisme. Saat ini, kami tidak mengizinkan orang lain untuk melakukan fork proyek ini atau membuat varian VisuAlgo. Penggunaan pribadi salinan offline dari sisi-klien VisuAlgo diperbolehkan.
Harap diperhatikan bahwa komponen kuis online VisuAlgo memiliki elemen sisi-server yang substansial, dan tidak mudah menyimpan skrip dan basis data sisi-server secara lokal. Saat ini, publik umum hanya dapat mengakses sistem kuis online melalui 'mode latihan.' 'Mode uji' menawarkan lingkungan yang lebih terkontrol untuk menggunakan pertanyaan yang dihasilkan secara acak dan verifikasi otomatis dalam ujian-ujian nyata di NUS.
Daftar Publikasi
Karya ini telah dipresentasikan singkat padaCLI Workshopsewaktu ACM ICPC World Finals 2012 (Poland, Warsaw) dan padaIOI Conferencedi IOI 2012 (Sirmione-Montichiari, Italy). Anda bisa mengkliklink iniuntuk membaca makalah kami tahun 2012 tentang sistem ini (yang belum disebut sebagai VisuAlgo pada tahun 2012 tersebut).
LaporanBugatau Permintaan Fitur Baru
VisuAlgo bukanlah proyek yang sudah selesai. Associate Professor Steven Halim masih aktif dalam mengembangkan VisuAlgo. Jika anda adalah pengguna VisuAlgo dan menemukanbugdi halaman visualisasi/sistem kuis online atau jika anda mau meminta fitur baru, silahkan hubungi Associate Professor Steven Halim. Alamat emailnya adalah gabungan dari namanya dan tambahkan gmail titik com.
Versi 1.2 (Dimutakhirkan Jum, 18 Aug 2023).Sejak Jumat, 18 Aug 2023, kami tidak lagi menggunakan Google Analytics. Semua cookie yang kami gunakan sekarang hanya untuk operasi situs web ini. Popup persetujuan cookie yang mengganggu sekarang dimatikan bahkan untuk pengunjung pertama kali.Sejak Jumat, 07 Jun 2023, berkat sumbangan yang murah hati dari Optiver, siapa pun di dunia bisa membuat akun VisuAlgo sendiri untuk menyimpan beberapa pengaturan kustomisasi (seperti mode layout, bahasa default, kecepatan pemutaran, dll).Selain itu, untuk mahasiswa NUS, dengan menggunakan akun VisuAlgo (sebuah tupel dari alamat email NUS resmi, nama murid resmi NUS seperti dalam daftar kelas, dan sebuah kata sandi yang dienkripsi pada sisi server — tidak ada data personal lainnya yang disimpan), anda memberikan ijin kepada dosen modul anda untuk melacak pembacaan slide-slide kuliah maya dan kemajuan latihan kuis online yang dibutuhkan untuk menjalankan modul tersebut dengan lancar. Akun VisuAlgo anda akan juga dibutuhkan untuk mengambil kuis-kuis VisuAlgo online resmi sehingga memberikan kredensial akun anda ke orang lain untuk mengerjakan Kuis Online sebagai anda adalah pelanggaran akademis. Akun pengguna anda akan dihapus setelah modul tersebut selesai kecuali anda memilih untuk menyimpan akun anda (OPT-IN). Akses ke basis data lengkap dari VisuAlgo (dengan kata-kata sandi terenkripsi) dibatasi kepada Prof Halim saja.Untuk dosen-dosen Ilmu Komputer di seluruh dunia yang telah menulis kepada Steven, sebuah akun VisuAlgo (alamat email (bukan-NUS), anda dapat menggunakan nama panggilan apapun, dan kata sandi terenkripsi) dibutuhkan untuk membedakan kredensial online anda dibandingkan dengan orang-orang lain di dunia. Akun anda akan dilacak seperti seorang murid NUS biasa diatas tetapi akun anda akan mempunya fitur-fiture spesifik untuk dosen-dosen Ilmu Komputer, yaitu kemampuan untuk melihat slide-slide tersembunyi yang berisi jawaban-jawaban (menarik) dari pertanyaan-pertanyaan yang dipresentasikan di slide-slide sebelumnya sebelum slide-slide tersembunyi tersebut. Anda juga dapat mengakses setingan Susah dari Kuis-Kuis Online VisuAlgo. Anda dapat dengan bebas menggunakan materi-materia untuk memperkaya kelas-kelas struktur-struktur data dan algoritma-algoritma anda. Catat bahwa mungkin ada fitur-fitur khusus tambahan untuk dosen Ilmu Komputer di masa mendatang.Untuk siapapun dengan akun VisuAlgo, anda dapat membuang akun anda sendiri bila anda tidak mau lagi diasosiasikan dengan tool VisuAlgo ini.

Profile
Training
Tests
Log Out
Legend:Green: languages with % translation and/or approval rate exceeding 70%, strive for full 100% :)Red: languages with % translation and/or approval rate lower than 30%, a lot more hard work are needed...
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
A graph is made up ofvertices/nodes andedges/lines that connect those vertices.
A graph may be undirected (meaning that there is no distinction between the two vertices associated with each bidirectional edge) or a graph may be directed (meaning that its edges are directed from one vertex to another but not necessarily in the other direction).
A graph may be weighted (by assigning a weight to each edge, which represent numerical values associated with that connection) or a graph may be unweighted (either all edges have unit weight 1 or all edges have the same constant weight).
Remarks: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.If you are an NUS student and a repeat visitor, pleaselogin.
Most graph problems that we discuss in VisuAlgo involvessimplegraphs.
In a simple graph, there is no(self-)loopedge (an edge that connects a vertex with itself) and nomultiple/paralleledges (edges between the same pair of vertices). In another word: There can only be up to one edge between a pair of distinct vertices.
The number of edgesEin a simple graph can only range from 0 to O(V2).
Graph algorithms on simple graphs are easier than on non-simple graphs.
Pro-tip 1: Since you are notlogged-in, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode:[PageDown]/[PageUp]to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use[→ or ↓/← or ↑]to do the same),and[Esc]to toggle between this e-Lecture mode and exploration mode.
An undirected edgee: (u,v) is said to be incident with its two end-point vertices:uandv. Two vertices are called adjacent (or neighbor) if they are incident with a common edge. For example, edge (0, 2) is incident to vertices 0+2 and vertices 0+2 are adjacent.
Two edges are called adjacent if they are incident with a common vertex. For example, edge (0, 2) and (2, 4) are adjacent.
The degree of a vertexvin an undirected graph is the number of edges incident with vertexv. A vertex of degree 0 is called an isolated vertex. For example, vertex 0/2/6 has degree 2/3/1, respectively.
A subgraphG'of a graphGis a (smaller) graph that contains subset of vertices and edges ofG. For example, a triangle {0, 1, 2} is a subgraph of the currently displayed graph.
Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolutionor larger(typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (F11) to enjoy this setup. However, you can use zoom-in (Ctrl +) or zoom-out (Ctrl -) to calibrate this.
A path (of lengthn) in an (undirected) graphGis a sequence of vertices{v0, v1, ..., vn-1, vn}such that there is an edge betweenviandvi+1∀i∈ [0..n-1] along the path.
If there is no repeated vertex along the path, we call such path as a simple path.
For example, {0, 1, 2, 4, 5} is one simple path in the currently displayed graph.
Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode):Spacebarto play/pause/replay the animation,←/→to step the animation backwards/forwards, respectively, and-/+to decrease/increase the animation speed, respectively.
An undirected graphGis called connected if there is a path between every pair of distinct vertices ofG. For example, the currently displayed graph is not a connected graph.
An undirected graphCis called a connected component of the undirected graphGif:1).Cis a subgraph ofG;2).Cis connected;3). no connected subgraph ofGhasCas a subgraph and contains vertices or edges that are not inC(i.e.,Cis the maximal subgraph that satisfies the other two criteria).
For example, the currently displayed graph have {0, 1, 2, 3, 4} and {5, 6} as its two connected components.
A cut vertex/bridge is a vertex/edge that increases the graph's number of connected components if deleted. For example, in the currently displayed graph, there is no cut vertex, but edge (5, 6) is a bridge.
In a directed graph, some of the terminologies mentioned earlier have small adjustments.
If we have a directed edgee: (u→v), we say thatvis adjacent toubut not necessarily in the other direction. For example, 1 is adjacent to 0 but 0 is not adjacent to 1 in the currently displayed directed graph.
In a directed graph, we have to further differentiate the degree of a vertexvinto in-degree and out-degree. The in-degree/out-degree is the number of edges coming-into/going-out-fromv, respectively. For example, vertex 1 has in-degree/out-degree of 2/1, respectively.
In a directed graph, we extend the concept of Connected Component (CC) intoStronglyConnected Component (SCC). A directed graphGis called strongly connected if there is a pathin each directionbetween every pair of distinct vertices ofG.
A directed graphSCCis called a strongly connected component of the directed graphGif:1).SCCis a subgraph ofG;2).SCCisstronglyconnected;3). no connected subgraph ofGhasSCCas a subgraph and contains vertices or edges that are not inSCCC(i.e.,SCCis the maximal subgraph that satisfies the other two criteria).
In the currently displayed directed graph, we have {0}, {1, 2, 3}, and {4, 5, 6, 7} as its three SCCs.
A cycle is a path that starts and ends with the same vertex.
An acyclic graph is a graph that contains no cycle.
In an undirected graph, each of its undirected edge causes atrivialcycle (of length 2) although we usually will not classify it as a cycle.
A directed graph that is also acyclic has a special name: Directed Acyclic Graph (DAG), as shown above.
There are interesting algorithms that we can perform on acyclic graphs that will be explored in this visualization page and in other graph visualization pages in VisuAlgo.
A graph with specific properties involving its vertices and/or edges structure can be called with its specific name, like Tree (like the one currently shown), Complete Graph, Bipartite Graph, Directed Acyclic Graph (DAG), and also the less frequently used: Planar Graph, Line Graph, Star Graph, Wheel Graph, etc.
In this visualization, we will highlightthe first four special graphs later.
Graph appears very often in various form in real life. The most important part in solving graph problem is thus thegraph modelingpart, i.e., reducing the problem in hand into graph terminologies: vertices, edges, weights, etc.
Social Network: Vertices can represent people, Edges represent connection between people (usually undirected and unweighted).
For example, see the undirected graph that is currently shown. This graph shows 7 vertices (people) and 8 edges (connection/relationship) between them. Perhaps we can ask questions like these:
Who is/are the friend(s) of people no 0?
Who has the most friend(s)?
Is there any isolated people (those with no friend)?
Is there a common friend between two strangers: People no 3 and people no 5?
Etc...
Transportation Network: Vertices can represent stations, edges represent connection between stations (usually weighted).
For example, see the directed weighted graph that is currently shown. This graph shows 5 vertices (stations/places) and 6 edges (connections/roads between stations, with positive weight travelling times as indicated). Suppose that we are driving a car. We can perhaps ask what is the path to take to go from station 0 to station 4 so that we reach station 4 using the least amount of time?
Discussion: Think of a few other real life scenarios which can be modeled as a graph.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
To toggle between the graph drawing modes, select the respective header. We have:
U/U = Undirected/Unweighted,
U/W = Undirected/Weighted,
D/U = Directed/Unweighted, and
D/W = Directed/Weighted.
We restrict the type of graphs that you can draw according to the selected mode.
You can click any one of the example graphs and see its example graph drawing, which is a two-dimensional depiction of that graph. Note that the same graph can have (infinitely) many possible graph drawings.
You can further edit (add/delete/reposition the vertices or add/change the weight of/delete the edges) the currently displayed graph by clicking "Edit Graph" (read the associated Help message in that Edit Graph window).
We limit the graphs discussed in VisuAlgo to besimplegraphs. Refer to its discussion inthis slide.
While now we do not really limit the number of vertices that you can draw on screen, we recommend that you draw not more than 10 vertices, ranging from vertex 0 to vertex 9 (as the Adjacency Matrix of this graph will already contain 10x10 = 100 cells). This, together with the simple graph constraint earlier, limit the number of undirected/directed edges to be 45/90, respectively.
All example graphs can be found here. We provide seven "most relevant" example graphs per category (U/U, U/W, D/U, D/W).
Remember that after loading one of these example graphs, you can further edit the currently displayed graph to suit your needs.
Tree, Complete, Bipartite, Directed Acyclic Graph (DAG) are properties of special graphs. As you edit the graph, these properties are checked and updated instantly.
There are other less frequently used special graphs: Planar Graph, Line Graph, Star Graph, Wheel Graph, etc, but they are not currently auto-detected in this visualization.
Treeis a connected graph withVvertices andE = V-1edges, acyclic, and hasone unique pathbetween any pair of vertices. Usually a Tree is defined on undirected graph.
An undirected Tree (see above) actually contains trivial cycles (caused by its bidirectional edges) but it does not contain non-trivial cycle (of length 3 or larger). A directed Tree is clearly acyclic.
As a Tree only haveV-1edges, it is usually considered asparsegraph.
We currently show ourU/U: Treeexample. You can go to 'Exploration Mode' and edit/draw your own trees.
Not all Trees have the same graph drawing layout of having a special root vertex at the top and leaf vertices (vertices with degree 1) at the bottom. The (star) graph shown above is also a Tree as it satisfies the properties of a Tree.
Tree with one of its vertex designated as root vertex is called a rooted Tree.
We can always transform any Tree into a rooted Tree by designating a specific vertex (usually vertex 0) as the root, and run aDFS or BFS algorithmfrom the root. This process of "rooting the tree" (of a Tree that is not visually drawn as a tree yet) has a visual explanation. Imagine that each vertex is a small ball (with non-zero weight) and each edge is a rope of the same length connecting two adjacent balls. Now, if we pick the root ball/vertex and pull it up, then gravity will pull the rest of the balls downwards and that is the DFS/BFS spanning tree of the tree.
In a rooted tree, we have the concept of hierarchies (parent, children, ancestors, descendants), subtrees, levels, and height. We will illustrate these concepts via examples as their meanings are as with real-life counterparts:
The parent of 0/1/7/9/4 are none/0/1/8/3, respectively,
The children of 0/1/7 are {1,8}/{2,3,6,7}/none, respectively,
The ancestors of 4/6/8 are {3,1,0}/{1,0}/{0}, respectively,
The lowest common ancestor between 4 and 6 is 1.
The descendants of 1/8 are {2,3,4,5,6,7}/{9}, respectively,
The subtree rooted at 1 includes 1, its descendants, and all associated edges,
Level 0/1/2/3 members are {0}/{1,8}/{2,3,6,7,9}/{4,5}, respectively,
The height of this rooted tree is its maximum level = 3.
For rooted tree, we can also define additional properties:
A binary tree is a rooted tree in which a vertex has at most two children that are aptly named: left and right child. We frequently see this form during the discussion ofBinary Search TreeandBinary Heap.
A full binary tree is a binary tree in which each non-leaf (also called the internal) vertex has exactly two children. The binary tree shown above fulfils this criteria.
A complete binary tree is a binary tree in which every level is completely filled, except possibly the last level may be filled as far left as possible. We frequently see this form especially during discussion ofBinary Heap.
Completegraph is a graph withVvertices andE = V*(V-1)/2edges (orE= O(V2)), i.e., there is an edge between any pair of vertices. We denote a Complete graph withVvertices asKV.
Complete graph is themost densesimple graph.
We currently show ourU/W: K5(Complete)example. You can go to 'Exploration Mode' and edit/draw your own complete graphs (a bit tedious for largerVthough).
Bipartitegraph is an undirected graph withVvertices that can be partitioned into two disjoint set of vertices of sizemandnwhereV = m+n. There is no edge between members of the same set. Bipartite graph is also free from odd-length cycle.
We currently show ourU/U: Bipartiteexample. You can go to 'Exploration Mode' and draw/edit your own bipartite graphs.
A Bipartite Graph can also be complete, i.e., allmvertices from one disjoint set are connected to allnvertices from the other disjoint set. Whenm = n = V/2, such Complete Bipartite Graphs also haveE= O(V2).
A Tree is also a Bipartite Graph, i.e., all vertices on the even levels form one set, and all vertices on the odd levels form the other set.
Directed Acyclic Graph (DAG)is a directed graph that has no cycle, which is very relevant forDynamic Programming (DP)techniques.
Each DAG has at least oneTopological Sort/Orderwhich can be found with a simple tweak to DFS/BFS Graph Traversal algorithm. DAG will be revisited again inDP technique for SSSP on DAG.
We currently show ourD/W: Four 0→4 Pathsexample. You can go to 'Exploration Mode' and draw your own DAGs.
There are many ways to store graph information into a graph data structure. In this visualization, we show three graph data structures: Adjacency Matrix, Adjacency List, and Edge List — each with its own strengths and weaknesses.
Adjacency Matrix (AM) is a square matrix where the entry AM[i][j] shows the edge's weight from vertex i to vertex j. For unweighted graphs, we can set a unit weight = 1 for all edge weights.
We usually set AM[i][j] = 0 to indicate that there is no edge (i, j). However, if the graph contains 0-weighted edge, we have to use another symbol to indicate "no edge" (e.g., -1, None, null, etc).
We simply use a C++/Python/Java native 2D array/list of sizeVxVto implement this data structure.
Space Complexity Analysis: An AM unfortunately requires a big space complexity of O(V2), even when the graph is actually sparse (not many edges).
Discussion: Knowing the large space complexity of AM, when is it beneficial to use it? Or is AM always an inferior graph data structure and should not be used at all times?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Adjacency List (AL) is an array ofVlists, one for each vertex (usually in increasing vertex number) where for each vertex i,AL[i]stores the list of i's neighbors. For weighted graphs, we can store pairs of (neighbor vertex number, weight of this edge) instead.
We use a Vector of Vector pairs (for weighted graphs) to implement this data structure.In C++:vector<vector<pair<int, int>>> AL;In Python:AL = [[] for _ in range(N)]In Java:Vector<Vector<IntegerPair>> AL;// class IntegerPair in Java is like pair<int, int> in C++
class IntegerPair implements Comparable<IntegerPair> {Integer _f, _s;public IntegerPair(Integer f, Integer s) { _f = f; _s = s; }public int compareTo(IntegerPair o) {if (!this.first().equals(o.first())) // this.first() != o.first()return this.first() - o.first();   // is wrong as we want toelse                                 // compare their values,return this.second() - o.second(); // not their references}Integer first() { return _f; }Integer second() { return _s; }}// IntegerTriple is similar to IntegerPair, just that it has 3 fields
We use pairs as we need to store pairs of information for each edge: (neighbor vertex number, edge weight) where the weight field can be set to 1, 0, unused, or simply dropped for unweighted graph.
We use Vector of Pairs due to Vector's auto-resize feature. If we havekneighbors of a vertex, we just addktimes to an initially empty Vector of Pairs of this vertex (this Vector can be replaced with Linked List).
We use Vector of Vectors of Pairs for Vector's indexing feature, i.e., if we want to enumerate neighbors of vertexu, we use AL[u] (C++/Python) or AL.get(u) (Java) to access the correct Vector of Pairs.
Space Complexity Analysis: AL has space complexity of O(V+E), which is much more efficient than AM and usually the default graph DS inside most graph algorithms.
Discussion: AL is the most frequently used graph data structure, but discuss several scenarios when AL is actuallynotthe best graph data structure?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Edge List (EL) is a collection of edges with both connecting vertices and their weights. Usually, these edges are sorted by increasing weight, e.g., part ofKruskal's algorithmfor Minimum Spanning Tree (MST) problem. However in this visualization, we sort the edges based on increasing first vertex number and if ties, by increasing second vertex number. Note that Bidirectional edges in undirected/directed graph are listed once/twice, respectively.
We use a Vector of triples to implement this data structure.In C++:vector<tuple<int, int, int>> EL;In Python:EL = []In Java:Vector<IntegerTriple> EL;// class IntegerTriple in Java is like tuple<int, int, int> in C++
Space Complexity Analysis: EL has space complexity of O(E), which is much more efficient than AM and as efficient as AL.
Discussion: Elaborate the potential usage of EL other than insideKruskal's algorithmfor Minimum Spanning Tree (MST) problem!
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
After storing our graph information into a graph DS, we can answera fewsimple queries.
CountingV,
CountingE,
Enumerating neighbors of a vertexu,
Checking the existence of edge(u, v), etc.
In an AM and AL,Vis just the number of rows in the data structure that can be obtained in O(V) or even in O(1) — depending on the actual implementation.
Discussion: How to countVif the graph is stored in an EL?
PS: Sometimes this number is stored/maintained in a separate variable so that we do not have to re-compute this every time — especially if the graph never/rarely changes after it is created, hence O(1) performance, e.g., we can store that there are 7 vertices (in our AM/AL/EL data structure) for the example graph shown above.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
In an EL,Eis just the number of its rows that can be counted in O(E) or even in O(1) — depending on the actual implementation. Note that depending on the need, we may store a bidirectional edge just once in the EL but on other case, we store both directed edges inside the EL.
In an AL,Ecan be found by summing the length of allVlists and divide the final answer by 2 (for undirected graph). This requires O(V+E) computation time as each vertex and each edge is only processed once. This can also be implemented in O(V) in some implementations.
Discussion: How to countEif the graph is stored in an AM?
PS: Sometimes this number is stored/maintained in a separate variable for efficiency, e.g., we can store that there are 8 undirected edges (in our AM/AL/EL data structure) for the example graph shown above.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
In an AM, we need to loop through all columns of AM[u][j] ∀j ∈ [0..V-1] and report pair of (j, AM[u][j]) if AM[u][j] is not zero. This is O(V) — slow.
In an AL, we just need to scan AL[u]. If there are onlykneighbors of vertexu, then we just need O(k) to enumerate them — this is called anoutput-sensitivetime complexity and is already the best possible.
We usually list the neighbors in increasing vertex number. For example, neighbors of vertex 1 in the example graph above are {0, 2, 3}, in that increasing vertex number order.
Discussion: How to do this if the graph is stored in an EL?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
In an AM, we can simply check if AM[u][v] is non zero. This is O(1) — the fastest possible.
In an AL, we have to check whether AL[u] contains vertexvor not. This is O(k) — slower.
For example, edge (2, 4) exists in the example graph above but edge (2, 6) does not exist.
Note that if we have found edge (u, v), we can also access and/or update its weight.
Discussion: How to do this if the graph is stored in an EL?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Quiz:So, what is the best graph data structure?
Discussion: Why?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
You have reached the end of the basic stuffs of this relatively simple Graph Data Structures and we encourage you to explore further in theExploration Modeby editing the currently drawn graph, by drawingyour owncustom graphs, or by inputting Edge List/Adjacency Matrix/Adjacency List input and ask VisuAlgo to propose a "good enough" graph drawing of that input graph.
However, we still have a few more interesting Graph Data Structures challenges for you that are outlined in this section.
Note that graph data structures are usually just the necessary but not sufficient part to solve the harder graph problems likeMST,SSSP,MF,Matching,MVC,ST, orTSP.
For a few more interesting questions about this data structure, please practice onGraph Data Structurestraining module.
Please look at the following C++/Python/Java/OCaml implementations of the three graph data structures mentioned in this e-Lecture: Adjacency Matrix, Adjacency List, and Edge List:graph_ds.cpp|py|java|ml.
Try to solve two basic programming problems that somewhat requires the usage of graph data structure without any fancy graph algorithms:UVa 10895 - Matrix Transposeand,Kattis - flyingsafely.←→🕑
UVa 10895 - Matrix Transposeand,
Kattis - flyingsafely.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Last but not least, there are some graphs that are so nicely structured that we do not have to actually store them in anygraph data structurethat we have discussed earlier.
For example, a completeunweightedgraph can be simply stored with just one integerV, i.e., we just need to remember it's size and since a complete graph has an edge between any pair of vertices, we can re-construct all thoseV * (V-1) / 2edges easily.
Discussion: Can you elaborate a few more implicit graphs?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
You have reached the last slide. Return to 'Exploration Mode' to start exploring!
Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.
Edit Graph
Input Graph
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
Given a graph, we can use the O(V+E) DFS (Depth-First Search) or BFS (Breadth-First Search) algorithm to traverse the graph and explore the features/properties of the graph. Each algorithm has its own characteristics, features, and side-effects that we will explore in this visualization.
This visualization is rich with a lot of DFS and BFS variants (all run in O(V+E)) such as:
Topological Sort algorithm (both DFS and BFS/Kahn's algorithm version),
Bipartite Graph Checker algorithm (both DFS and BFS version),
Cut Vertex & Bridge finding algorithm,
Strongly Connected Components (SCC) finding algorithms(both Kosaraju's and Tarjan's version), and
2-SAT Checker algorithm.
Remarks: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.If you are an NUS student and a repeat visitor, pleaselogin.
When the chosen graph traversal algorithm is running, the animation will be shown here.
We use vertex+edge color (the color scheme will be elaborated soon) and occasionally the extra text under the vertex (inred font) to highlight the changes.
All graph traversal algorithms work on directed graphs (this is the default setting, where each edge has an arrowtip to indicate its direction) but theBipartite Graph Checkalgorithm and theCut Vertex & Bridgefinding algorithm requires the undirected graphs (the conversion is done automatically by this visualization).
Pro-tip 1: Since you are notlogged-in, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode:[PageDown]/[PageUp]to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use[→ or ↓/← or ↑]to do the same),and[Esc]to toggle between this e-Lecture mode and exploration mode.
There are three different sources for specifying an input graph:
Edit Graph: You can draw a new graph or edit an example unweighted directed graph as the input graph (to draw bidirectional edge (u, v), you can draw two directed edges u → v and v → u; or click 'Include Reverse Edges' button to do this for all directed edges).
Input Graph: You can specify Edge List/Adjacency Matrix/Adjacency List information and VisuAlgo will propose a 2D graph drawing layout of that graph.
Example Graphs: You can select from the list of our selected example graphs to get you started.
Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolutionor larger(typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (F11) to enjoy this setup. However, you can use zoom-in (Ctrl +) or zoom-out (Ctrl -) to calibrate this.
If you arrive at this e-Lecturewithouthaving first explore/master the concept ofBinary Heapand especiallyBinary Search Tree, we suggest that you explore them first, as traversing a (Binary) Tree structure is much simpler than traversing a general graph.
Quiz:Mini pre-requisite check. What are the Pre-/In-/Post-order traversal of the binary tree shown (root = vertex 0), left and right child are as drawn?
Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode):Spacebarto play/pause/replay the animation,←/→to step the animation backwards/forwards, respectively, and-/+to decrease/increase the animation speed, respectively.
We normally start from the most important vertex of a (binary) tree: Therootvertex.
If the given tree is not 'rooted' (see the example picture), we can pick any one vertex (for example, vertex 0 in the example picture) and designate it as the root. If we imagine that all edges are strings of similar length, then after "virtually pulling the designated root upwards" and let gravity pulls the rest downwards, we have a rooted directed (downwards) tree — see the next slide.
PS: Technically, this transformation is done by runningDFS(0)that we will explore soon.
DFS(0)
In abinarytree, we only haveup to twoneighboring choices: From the current vertex, we can go to the left subtree first or go to the right subtree first. We also have option to visit the current vertex before or after visiting one of the (or both) subtree(s).
This gives rise to the classics: pre-order (visit current vertex, visit its left subtree, visit its right subtree), in-order (left, current, right), and post-order (left, right, current) traversals.
Discussion: Do you notice that there are three other possible binary tree traversal combinations? What are they?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
In a binary tree, or in a tree structure in general, there is no (non-trivial) cycle involving 3 or more distinct vertices to worry about (we do not consider the trivial cycle involving bi-directional edges which can be taken care of easily — see three slides earlier).
In general graph, we do not have the notion of root vertex. Instead, we need to pick one distinguished vertex to be the starting point of the traversal, i.e. the source vertexs.
We also have 0, 1, ...,kneighbors of a vertex instead of just ≤ 2.
Wemay (or actually very likely)have cycle(s) in our general graph instead of acyclic tree,be it the trivial one like u → v → u or the non-trivial one like a → b → c → a.
But fret not, graph traversal is an easy problem with two classic algorithms: DFS and BFS.
One of the most basic graph traversal algorithm is the O(V+E) Depth-First Search (DFS).
DFS takes one input parameter: The source vertexs.
DFS is one of the most fundamental graph algorithm, so please spend time to understand the key steps of this algorithm.
The closest analogy of the behavior of DFS is to imagine a maze with only one entrance and one exit. You are at the entrance and want to explore the maze to reach the exit. Obviously you cannot split yourself into more than one.
Ask these reflective questions before continuing: What will you do if there are branching options in front of you? How to avoid going in cycle? How to mark your own path? Hint: You need a chalk, stones (or any other marker) and a (long) string.
As it name implies, DFS starts from a distinguished source vertexsand uses recursion (an implicit stack) to order the visitation sequence as deep as possible before backtracking.
If DFS is at a vertexuand it hasXneighbors, it will pick the first neighborV1(usually the vertex with the lowest vertex number), recursively explore all reachable vertices from vertexV1, and eventually backtrack to vertexu. DFS will then do the same for the other neighbors until it finishes exploring the last neighborVXand its reachable vertices.
This wordy explanation will be clearer with DFS animation later.
If the graph iscyclic, the previous 'try-all' strategy may lead DFS to run in cycle.
Sothe basic form of DFSuses an arraystatus[u]of sizeVvertices to decide betweenbinary conditions: Whether vertexuhas been visited or unvisited. Only if vertexuis still unvisited, then DFS can visit vertexu.
When DFS runs out of option, itbacktrackto previous vertex (p[u], see the next slide) as the recursion unwinds.
DFS uses another arrayp[u]of sizeVvertices to remember theparent/predecessor/previousof each vertexualong the DFS traversal path.
The predecessor of the source vertex, i.e.,p[s]is set to -1 to say that the source vertex has no predecessor (as the lowest vertex number is vertex 0).
The sequence of vertices from a vertexuthat is reachable from the source vertexsback tosforms theDFS spanning tree. We color thesetree edgeswithred color.
For now, ignore the extrastatus[u] = exploredin the displayed pseudocode and the presence ofblueandgreyedges in the visualization (to be explained soon).
Without further ado, let's executeDFS(0)on the default example graph for this e-Lecture (CP4 Figure 4.1).Recap DFS Example
Thebasic versionof DFS presented so far is already enough for most simple cases.
The time complexity of DFS is O(V+E) because:
Each vertex is only visited once due to the fact that DFS will only recursively explore a vertexuifstatus[u] = unvisited— O(V)
Every time a vertex is visited, all itskneighbors are explored and therefore after all vertices are visited, we have examined allEedges — (O(E) as the total number of neighbors of each vertex equals toE).
The O(V+E) time complexity of DFS only achievable if we can visit allkneighboring vertices of a vertex in O(k) time.
Quiz:Which underlying graph data structure support that operation?
Discussion: Why?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Another basic graph traversal algorithm is the O(V+E) Breadth-First Search (BFS).
As with DFS, BFS also takes one input parameter: The source vertexs.
Both DFS and BFS have their own strengths and weaknesses. It is important to learn both and apply the correct graph traversal algorithm for the correct situation.
Imagine a still body of water and then you throw a stone into it. The first location where the stone hits the water surface is the position of the source vertex and the subsequentripple effectacross the water surface is like the BFS traversal pattern.
BFS is very similar with DFS that have been discussed earlier, but with some differences.
BFS starts from a source vertexsbut it uses aqueueto order the visitation sequenceas breadth as possible before going deeper.
BFS also uses a Boolean array of sizeVvertices to distinguish between two states: visited and unvisited vertices (we will not use BFS to detect back edge(s) as with DFS).
In this visualization, we also show that starting from the same source vertexsin anunweighted graph, BFS spanning tree of the graph equals to itsSSSP spanning tree.
Without further ado, let's executeBFS(5)on the default example graph for this e-Lecture (CP4 Figure 4.2).Recap BFS Example.
Notice theBreadth-firstexploration due to the usage of FIFO data structure: Queue?
The time complexity of BFS is O(V+E) because:
Each vertex is only visited once as it can only enter the queue once — O(V)
Every time a vertex is dequeued from the queue, all itskneighbors are explored and therefore after all vertices are visited, we have examined allEedges — (O(E) as the total number of neighbors of each vertex equals toE).
As with DFS, this O(V+E) time complexity is only possible if we useAdjacency Listgraph data structure — same reason as with DFS analysis.
So far, we can use DFS/BFS to solve a few graph traversal problem variants:
Reachability test,
Actually printing the traversal path,
Identifying/Counting/Labeling Connected Components (CCs) of undirected graphs,
Detecting if a graph is cyclic,
Topological Sort (only on DAGs),
For most data structures and algorithms courses, the applications of DFS/BFS are up to these few basic ones only, although DFS/BFS can do much more...
If you are asked to test whether a vertexsand a (different) vertextin a graph are reachable, i.e., connected directly (via a direct edge) or indirectly (via a simple, non cyclic, path), you can call the O(V+E)DFS(s)(orBFS(s)) and check ifstatus[t] = visited.
Example 1:s = 0andt = 4, runDFS(0)and notice thatstatus[4] = visited.Example 2:s = 0andt = 7, runDFS(0)and notice thatstatus[7] = unvisited.
Rememberthat we setp[v] = uevery time we manage to extend DFS/BFS traversal from vertexuto vertexv— a tree edge in the DFS/BFS spanning tree. Thus, we can use following simple recursive function to print out the path stored in arrayp. Possible follow-up discussion: Can you write this initerativeform? (trivial)
method backtrack(u)if (u == -1) stopbacktrack(p[u]);output vertex u
To print out the path from a source vertexsto a target vertextin a graph, you can call O(V+E)DFS(s)(orBFS(s)) and then O(V)backtrack(t). Example:s = 0andt = 4, you can callDFS(0)and thenbacktrack(4).Elaborate
We can enumerateallvertices that are reachable from a vertexsin anundirected graph(as the example graph shown above) by simply calling O(V+E)DFS(s)(orBFS(s)) and enumerate all vertexvthat hasstatus[v] = visited.
Example:s = 0, runDFS(0)and notice thatstatus[{0,1,2,3,4}] = visitedso they are all reachable vertices from vertex 0, i.e., they form oneConnected Component (CC).
We can use the following pseudo-code to count the number of CCs:
CC = 0for all u in V, set status[u] = unvisitedfor all u in Vif (status[u] == unvisited)++CC // we can use CC counter number as the CC labelDFS(u) // or BFS(u), that will flag its members as visitedoutput CC // the answer is 3 for the example graph above, i.e.// CC 0 = {0,1,2,3,4}, CC 1 = {5}, CC 2 = {6,7,8}
You can modify the DFS(u)/BFS(u) code a bit if you want to use it to label each CC with the identifier of that CC.
Quiz:What is the time complexity of Counting the Number of CCs algorithm?
Discussion: Why?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
We can actuallyaugmentthe basic DFS further to give more insights about the underlying graph.
In this visualization, we useblue colorto highlightbackedge(s) of the DFS spanning tree. The presence of at least one back edge shows that the traversed graph (component) iscyclicwhile its absence shows that at least the component connected to the source vertex of the traversed graph isacyclic.
Back edge can be detected by modifying arraystatus[u]to recordthreedifferent states:
unvisited: same as earlier, DFS has not reach vertexubefore,
explored: DFS has visited vertexu, but at least one neighbor of vertexuhas not been visited yet (DFS will go depth-first to that neighbor first),
visited: now stronger definition: all neighbors of vertexuhave also been visited and DFS is about to backtrack from vertexuto vertexp[u].
If DFS is now at vertexxand explore edgex → yand encounterstatus[y] = explored, we can declarex → yis aback edge(a cycle is found as we were previously at vertexy(hencestatus[y] = explored), go deep to neighbor ofyand so on, but we are now at vertexxthat is reachable fromybut vertexxleads back to vertexy).
The edges in the graph that are nottree edge(s)norback edge(s)are coloredgrey. They are calledforward or cross edge(s)and currently have limited use (not elaborated).
Now tryDFS(0)on the example graph above with this new understanding, especially about the 3 possible status of a vertex (unvisited/normal black circle, explored/blue circle,visited/orange circle) andback edge. Edge 2 → 1 will be discovered as a back edge as it is part of cycle 1 → 3 → 2 → 1 (as vertex 2 is `explored' to vertex 1 which is currently `explored') (similarly with Edge 6 → 4 as part of cycle 4 → 5 → 7 → 6 → 4).
Note that if edges 2 → 1 and 6 → 4 are reversed to 1 → 2 and 4 → 6, then the graph is correctly classified as acyclic as edge 3 → 2 and 4 → 6 go from `explored' to `fully visited'. If we only use binary states: `unvisited' vs `visited', we cannot distinguish these two cases.
There is another DFS (and also BFS) application that can be treated as 'simple': Performing Topological Sort(ing) of a Directed Acyclic Graph (DAG) — see example above.
Topological sort of a DAG is a linear ordering of the DAG's vertices in which each vertex comes before all vertices to which it has outbound edges.
Every DAG (can be checked withDFS earlier) has at least one but possibly more topological sorts/ordering.
One of the main purpose of (at least one) topological sort of a DAG is forDynamic Programming (DP)technique. For example, this topological sorting process is used internally inDP solution for SSSP on DAG.
We can use either the O(V+E) DFS or BFS to perform Topological Sort of a Directed Acyclic Graph (DAG).
The DFS version requires just one additional line compared to the normal DFS and is basically the post-order traversal of the graph. TryToposort (DFS)on the example DAG.
The BFS version is based on the idea of vertices without incoming edge and is also called as Kahn's algorithm. TryToposort (BFS/Kahn's)on the example DAG.
We can use the O(V+E) DFS or BFS (they work similarly) to check if a given graph is a Bipartite Graph by giving alternating color (orangeversusbluein this visualization) between neighboring vertices and report 'non bipartite' if we ends up assigning same color to two adjacent vertices or 'bipartite' if it is possible to do such '2-coloring' process. TryDFS_CheckerorBFS_Checkeron the example Bipartite Graph.
Bipartite Graphs have useful applications in(Bipartite) Graph Matching problem.
Note that Bipartite Graphs are usually only defined for undirected graphs so this visualization will convert directed input graphs into its undirected version automatically before continuing. This action is irreversible and you may have to redraw the directed input graph again for other purposes.
As of now, you have seen DFS/BFS and what it can solve (with just minor tweaks). There are a few more advanced applications that require more tweaks and we will let advanced students to explore them on their own:
Finding Articulation Points (Cut Vertices) and Bridges of an Undirected Graph (DFS only),
Finding Strongly Connected Components (SCCs) of a Directed Graph (Tarjan's and Kosaraju's algorithms), and
2-SAT(isfiability) Checker algorithms.
Advertisement: The details are written inCompetitive Programming book.
We can modify (but unfortunately, not trivially) the O(V+E) DFS algorithm into an algorithm to find Cut Vertices & Bridges of an Undirected Graph.
A Cut Vertex, or an Articulation Point, is a vertex of an undirected graph which removal disconnects the graph. Similarly, a bridge is an edge of an undirected graph which removal disconnects the graph.
Note that this algorithm for finding Cut Vertices & Bridges only works for undirected graphs so this visualization will convert directed input graphs into its undirected version automatically before continuing. This action is irreversible and you may have to redraw the directed input graph again for other purposes. You can try toFind Cut Vertices & Bridgeson the example graph above.
We can modify (but unfortunately, not trivially) the O(V+E) DFS algorithm into an algorithm to find Strongly Connected Components (SCCs) of a Directed Graph G.
An SCC of a directed graph G a is defined as a subgraph S of G such that for any two vertices u and v in S, vertex u can reach vertex v directly or via a path, and vertex v can also reach vertex u back directly or via a path.
There are two known algorithms for finding SCCs of a Directed Graph: Kosaraju's and Tarjan's. Both of them are available in this visualization. TryKosaraju's Algorithmand/orTarjan's Algorithmon the example directed graph above.
We also have the 2-SAT Checker algorithm. Given a 2-Satisfiability (2-SAT) instance in the form of conjuction of clauses: (clause1) ^ (clause2) ^ ... ^ (clausen) and each clause is in form of disjunction of up to two variables (varav varb), determine if we can assign True/False values to these variables so that the entire 2-SAT instance is evaluated to be true, i.e. satisfiable.
It turns out that each clause (a v b) can be turned into four vertices a, not a, b, and not b with two edges: (not a → b) and (not b → a). Thus we have a Directed Graph. If there is at least one variable and its negation inside an SCC of such graph, we know that it is impossible to satisfy the 2-SAT instance.
After such directed graph modeling, we can run an SCC finding algorithm (Kosaraju's or Tarjan's algorithm) to determine the satisfiability of the 2-SAT instance.
Quiz:Which Graph Traversal Algorithm is Better?
Discussion: Why?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
There are lots of things that we can still do with just DFS and/or BFS...
There are interesting questions about these two graph traversal algorithms: DFS+BFS and variants of graph traversal problems, please practice onGraph Traversaltraining module (no login is required, but short and of medium difficulty setting only).
However, for registered users, you should login and then go to theMain Training Pageto officially clear this module and such achievement will be recorded in your user account.
We also have a few programming problems that somewhat requires the usage of DFS and/or BFS:Kattis - reachableroadsandKattis - breakingbad.
Try to solve them and then try themany moreinteresting twists/variants of this simple graph traversal problem and/or algorithm.
You are allowed to use/modify our implementation code for DFS/BFS Algorithms:dfs_cc.cpp/bfs.cppdfs_cc.java/bfs.javadfs_cc.py/bfs.pydfs_cc.ml/bfs.ml
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
You have reached the last slide. Return to 'Exploration Mode' to start exploring!
Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.
Edit Graph
Input Graph
Example Graphs
Depth-First Search
Breadth-First Search
Topological Sort
Bipartite Graph Check
Cut Vertex & Bridge
SCC Algorithms
2-SAT Checker
CP4 4.1
CP4 4.2
CP4 4.3 DAG
CP4 4.7
CP4 4.16*
CP4 4.20 DAG, Bipartite
CP4 4.22 Bipartite
Large Graph
Large, Cycles
CLRS 22.5 (with curvy edges)
Go
Go
DFS version
BFS version (Kahn's algorithm)
DFS version
BFS version
Kosaraju's Algorithm
Tarjan's Algorithm
GO
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
ASpanning Tree (ST)of a connected undirected weighted graphGis a subgraph ofGthat is atreeandconnects (spans) all vertices ofG. A graphGcan have many STs (seethisorthis), each with different total weight (the sum of edge weights in the ST).
AMin(imum) Spanning Tree (MST)ofGis an ST ofGthat has thesmallest total weightamong the various STs.
Remarks: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.If you are an NUS student and a repeat visitor, pleaselogin.
TheMSTproblem is a standard graph (and also optimization) problem defined as follows: Given a connected undirected weighted graphG = (V, E), select asubsetof edges ofGsuch that the graph is still connected but with minimum total weight. The output is either the actual MST ofG(there can be several possible MSTs ofG) or usually just the minimum total weight itself (this is unique).
Pro-tip 1: Since you are notlogged-in, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode:[PageDown]/[PageUp]to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use[→ or ↓/← or ↑]to do the same),and[Esc]to toggle between this e-Lecture mode and exploration mode.
Government wants to linkNrural villages in the country withN-1roads.(that is aspanning treewithNvertices andN-1edges).
The cost to build a road to connect two villages depends on the terrain, distance, etc.(that is acomplete undirected weighted graphofN*(N-1)/2weighted edges).
You want to minimize the total building cost. How are you going to build the roads?(that isminimum spanning tree).
PS: There is a variant of this problem that requires more advanced solution, e.g., seethis.
Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolutionor larger(typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (F11) to enjoy this setup. However, you can use zoom-in (Ctrl +) or zoom-out (Ctrl -) to calibrate this.
TheMSTproblem has polynomial solutions.
In this visualization, we will learn two of them: Kruskal's algorithm and Prim's algorithm. Both are classified asGreedyAlgorithms. Note that there are other MST algorithms outside the two presented here.
Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode):Spacebarto play/pause/replay the animation,←/→to step the animation backwards/forwards, respectively, and-/+to decrease/increase the animation speed, respectively.
View the visualisation of MST algorithm above.
Originally, all vertices and edges in the input graph are colored with the standardblack color on white background.
At the end of the MST algorithm,|V|-1MST edges (and all|V|vertices) will be coloredorangeand non-MST edges will be coloredgrey.
There are two different sources for specifying an input graph:
Edit Graph: You can edit the currently displayed connected undirected weighted graph or draw your own input graph.
Example Graphs: You can select from the list of example connected undirected weighted graphs to get you started.
Kruskal's algorithm: An O(ElogV) greedy MST algorithm that grows a forest of minimum spanning trees and eventually combine them into one MST.
Kruskal's requiresa good sorting algorithmto sort edges of the input graph (usually stored in anEdge Listdata structure) by non-decreasing weight and another data structure calledUnion-Find Disjoint Sets (UFDS)to help in checking/preventing cycle.
Kruskal's algorithm first sort the set of edgesEin non-decreasing weight (there can be edges with the same weight), and if ties, by increasing smaller vertex number of the edge, and if still ties, by increasing larger vertex number of the edge.
Discussion: Is this the only possible sort criteria?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Then, Kruskal's algorithm will perform a loop through these sorted edges (that already have non-decreasing weight property) andgreedilytaking the next edgeeif it doesnotcreate any cycle w.r.t. edges that have been taken earlier.
Without further ado, let's tryKruskalon the default example graph (that has three edges with the same weight). Go through this animated example first before continuing.
To see on why theGreedy Strategyof Kruskal's algorithm works, we define aloop invariant: Every edgeethat is added into treeTby Kruskal's algorithm is part of theMST.
At the start of Kruskal's main loop,T = {}is always part ofMSTby definition.
Kruskal's has a special cycle check in its main loop (usingUFDSdata structure) and only add an edgeeintoTif it will never form a cycle w.r.t. the previously selected edges.
At the end of the main loop, Kruskal's can only selectV-1 edges from a connected undirected weighted graphGwithout having any cycle. This implies that Kruskal's produces a Spanning Tree.
On the default example, notice that after taking the first 2 edges: 0-1 and 0-3, in that order, Kruskal'scannottake edge 1-3 as it will cause a cycle 0-1-3-0. Kruskal's then take edge 0-2 but it cannot take edge 2-3 as it will cause cycle 0-2-3-0.
We have seen in the previous slide that Kruskal's algorithm will produce a treeTthat is a Spanning Tree (ST) when it stops. But is it the minimum ST, i.e., theMST?
To prove this, we need to recall thatbeforerunning Kruskal's main loop, we have already sort the edges in non-decreasing weight, i.e., the latter edges will have equal orlargerweight than the earlier edges.
At the start of every loop,Tis always part of MST.
If Kruskal's only add a legal edgee(that will not cause cycle w.r.t. the edges that have been taken earlier) withmin cost, then we can be sure thatw(T U e) ≤ w(T U any other unprocessed edge e' that does not form cycle)(by virtue that Kruskal's has sorted the edges, sow(e) ≤ w(e')).
Therefore, at the end of the loop, the Spanning TreeTmust have minimal overall weightw(T), soTis the final MST.
On the default example, notice that after taking the first 2 edges: 0-1 and 0-3, in that order, and ignoring edge 1-3 as it will cause a cycle 0-1-3-0, we can safely take the next smallest legal edge 0-2 (with weight 2) as taking any other legal edge (e.g., edge 2-3 withlargerweight 3) will either createanotherMST with equal weight (not in this example) oranotherST that is not minimum (which is this example).
There are two parts of Kruskal's algorithm: Sorting and the Kruskal's main loop.
The sorting of edges is easy. We just store the graph usingEdge Listdata structureand sortEedges using any O(ElogE) = O(ElogV)sorting algorithm(or just use C++/Python/Java sorting library routine) by non-decreasing weight, smaller vertex number, higher vertex number. This O(ElogV) is the bottleneck part of Kruskal's algorithm as the second part is actually lighter, see below.
Kruskal's main loop can be easily implemented usingUnion-Find Disjoint Setsdata structure. We useIsSameSet(u, v)to test if taking edgeewith endpointsuandvwill cause a cycle (same connected component -- there is another path in the subtree that can connectutov, thus adding edge(u, v)will cause a cycle) or not. IfIsSameSet(u, v)returns false, we greedily take this next smallest and legal edgeeand callUnionSet(u, v)to prevent future cycles involving this edge. This part runs in O(E) as we assume UFDSIsSameSet(u, v)andUnionSet(u, v)operations run in O(1) for a relatively small graph.
Prim's algorithm: Another O(ElogV) greedy MST algorithm that grows a Minimum Spanning Tree from a starting source vertex until it spans the entire graph.
Prim's requires a Priority Queue data structure (usually implemented usingBinary Heapbut we can also useBalanced Binary Search Treetoo) to dynamically order the currently considered edges based on non-decreasing weight, anAdjacency List data structurefor fast neighbor enumeration of a vertex, and a Boolean array (a Direct Addressing Table) to help in checking cycle.
Another name of Prim's algorithm is Jarnik-Prim's algorithm.
Prim's algorithm starts from a designated source vertexs(usually vertex 0) and enqueues all edges incident tosinto a Priority Queue (PQ) according to non-decreasing weight, and if ties, by increasing vertex number (of the neighboring vertex number). Then it will repeatedly do the following greedy steps: If the vertexvof the front-most edge pair informatione: (w, v)in the PQ hasnotbeen visited, it means that we can greedily extends the treeTto include vertexvand enqueue edges connected tovinto the PQ, otherwise we discard edgee(because Prim's grows one spanning tree froms, the fact thatvis already visited implies that there is another path fromstovand adding this edge will cause a cycle).
Without further ado, let's tryPrim(1)on the default example graph (that has three edges with the same weight). That's it, we start Prim's algorithm from source vertexs = 1. Go through this animated example first before continuing.
Prim's algorithm is aGreedy Algorithmbecause at each step of its main loop, it always try to select the next valid edgeewith minimal weight (that is greedy!).
To convince us that Prim's algorithm is correct, let's go through the following simple proof: LetTbe the spanning tree of graphGgenerated by Prim's algorithm andT*be the spanning tree ofGthat is known to have minimal cost, i.e.T*is theMST.
IfT == T*, that's it, Prim's algorithm produces exactly the sameMSTasT*, we are done.
But ifT != T*...
Assume that on the default example,T = {0-1, 0-3, 0-2}butT* = {0-1, 1-3, 0-2}instead.
Letek= (u, v)be the first edge chosen by Prim's Algorithm at thek-th iteration that is not inT*(on the default example,k = 2,e2= (0, 3), note that(0, 3)is not inT*).
LetPbe the path fromutovinT*, and lete*be an edge inPsuch that one endpoint is in the tree generated at the (k−1)-th iteration of Prim's algorithm and the other is not (on the default example,P = 0-1-3ande* = (1, 3), note that vertex1is insideTat first iterationk = 1).
If the weight ofe*is less than the weight ofek, then Prim's algorithm would have chosene*on itsk-th iteration as that is how Prim's algorithm works.
So, it is certain thatw(e*) ≥ w(ek).(on the example graph,e* = (1, 3)has weight 1 andek= (0, 3)also has weight 1).
When weighte*is = weightek, the choice between thee*orekis actually arbitrary. And whether the weight ofe*is ≥ weight ofek,e*can always be substituted withekwhile preserving minimal total weight ofT*. (on the example graph, when we replacee* = (1, 3)withek= (0, 3), we manage to transformT*intoT).
But ifT != T*... (continued)
We can repeat the substitution process outlined earlier repeatedly untilT* = Tand thereby we have shown that the spanning tree generated by any instance of Prim's algorithm (from any source vertexs) is an MST as whatever the optimal MST is, it can be transformed to the output of Prim's algorithm.
We can easily implement Prim's algorithm with two well-known data structures:
A Priority Queue PQ (Binary Heapinside C++ STL priority_queue/Python heapq/Java PriorityQueue orBalanced BSTinside C++ STL set/Java TreeSet), and
A Boolean array of sizeV, essentially aDirect Addressing Table(to decide if a vertex has been taken or not, i.e., in the same connected component as the source vertexsor not).
With these, we can run Prim's Algorithm in O(ElogV) because we process each edge once and each time, we callInsert((w, v))and(w, v) = ExtractMax()from a PQ in O(logE) = O(logV2) = O(2 logV) = O(logV). As there areEedges, Prim's Algorithm runs in O(ElogV).
Quiz:Having seen both Kruskal's and Prim's Algorithms, which one is the better MST algorithm?
Discussion: Why?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
You have reached the end of the basic stuffs of this Min(imum) Spanning Tree graph problem and its two classic algorithms: Kruskal's and Prim's (there are others, like another O(E log V)Boruvka'salgorithm, but not discussed in this visualization). We encourage you to explore further in theExploration Mode.
However, the harder MST problems can be (much) more challenging that its basic version.
Once you have (roughly) mastered this MST topic, we encourage you to study more on harder graph problems where MST is used as a component, e.g., approximation algorithm for NP-hard(Metric No-Repeat) TSPandSteiner Treeproblems.
We write a few MST problem variants in theCompetitive Programming book.
Max(imum) Spanning Tree,
Min(imum) Spanning Subgraph,
Min(imum) Spanning Forest,
Second Best Spanning Tree,
Minimax (Maximin) Path Problem, etc
Advertisement: Buy CP book to study more about these variants and see that sometimes Kruskal's is better and sometimes Prim's is better at some of these variants.
For a few more challenging questions about this MST problem and/or Kruskal's/Prim's Algorithms, please practice onMSTtraining module (no login is required, but on medium difficulty setting only).
However, for NUS students, you should login to officially clear this module and such achievement will be recorded in your user account.
This MST problem can be much more challenging than this basic form. Therefore we encourage you to try the following two ACM ICPC contest problems about MST:UVa 01234 - RACINGandKattis - arcticnetwork.
Try them to consolidate and improve your understanding about this graph problem.
You are allowed to use/modify our implementation code for Kruskal's/Prim's Algorithms:kruskal.cpp|py|java|mlprim.cpp|py|java|ml
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
You have reached the last slide. Return to 'Exploration Mode' to start exploring!
Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.
Edit Graph
Input Graph
Example Graphs
Kruskal's Algorithm
Prim's Algorithm(s)
CP 4.10
CP 4.14
K5
Rail
Tessellation
Large
Go
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
In theSingle-Source Shortest Paths (SSSP)problem, we aim to find the shortest paths weights (and the actual paths) from a particular single-source vertex to all other vertices in a directed weighted graph (if such paths exist).
The SSSP problem is a(nother) verywell-knownComputer Science (CS) problem thateveryCS students worldwide need to be aware of and hopefully master.
The SSSP problem has several different efficient (polynomial) algorithms (e.g., Bellman-Ford, BFS, DFS, Dijkstra — 2 versions, and/or Dynamic Programming) that can be used depending on the nature of the input directed weighted graph, i.e. weighted/unweighted, with/without (negative weight) cycle, or structurally special (a tree/a DAG).
Remarks: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.If you are an NUS student and a repeat visitor, pleaselogin.
SSSP is one of the most frequent graph problem encountered in real-life. Every time we want to move from one place (usually our current location) to another (our destination), we will try to pick a short — if not the shortest — path.
SSSP algorithm(s) is embedded inside various map software likeGoogle Mapsand in various Global Positioning System (GPS) tool.
Pro-tip 1: Since you are notlogged-in, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode:[PageDown]/[PageUp]to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use[→ or ↓/← or ↑]to do the same),and[Esc]to toggle between this e-Lecture mode and exploration mode.
Input 1: A directed weighted graph G(V, E), not necessarily connected, whereV/vertices can be used to describe intersections, junctions, houses, landmarks, etc andE/edges can be used to describe streets, roads, avenues with proper direction and weight/cost.
Input 2: As the name implies, the SSSP problem has another input: A source vertexs∈V.
Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolutionor larger(typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (F11) to enjoy this setup. However, you can use zoom-in (Ctrl +) or zoom-out (Ctrl -) to calibrate this.
The objective of the SSSP problem is to find the shortest path weight fromsto each vertexu∈V, denoted asδ(s, u)(δ is pronounced as 'delta') and also the actual shortest path fromstou.
The path weight of a pathpis simply the summation of edge weights along that path.
The weight of the shortest path fromstosis trivial: 0.The weight of the shortest path fromsto any unreachable vertex is also trivial: +∞.
PS: The weight of the shortest path fromstovwhere(s, v) ∈ Edoes not necessarily the weight ofw(s, v). See the next few slides to realise this.
Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode):Spacebarto play/pause/replay the animation,←/→to step the animation backwards/forwards, respectively, and-/+to decrease/increase the animation speed, respectively.
The outputs of all six (6) SSSP algorithms for the SSSP problem discussed in this visualization are these two arrays/Vectors:
An array/VectorDof sizeV(Dstands for 'distance')Initially,D[u]= 0 ifu=s; otherwiseD[u]= +∞ (a large number, e.g. 109)D[u]decreases as we find better (shorter) pathsD[u]≥δ(s, u)throughout the execution of SSSP algorithmD[u]=δ(s, u)at the end of SSSP algorithm
An array/Vectorpof sizeV(p stands for 'parent'/'predecessor'/'previous')p[u]= the predecessor on best path from sourcestoup[u]= NULL (not defined, we can use a value like -1 for this)This array/Vectorpdescribes the resulting SSSP spanning tree
Initially,D[u]= +∞ (practically, a large value like 109) ∀u∈V\{s}, butD[s]=D[0]= 0.Initially,p[u]= -1 (to say 'no predecessor') ∀u∈V.
Now clickDijkstra(0)— don't worry about the details as they will be explained later — and wait until it is over (approximately 10s on this small graph).
At the end of that SSSP algorithm,D[s]=D[0]= 0 (unchanged) andD[u]=δ(s, u)∀u∈Ve.g.,D[2]= 6,D[4]= 7 (these values are stored asred textunder each vertex).At the end of that SSSP algorithm,p[s]=p[0]= -1 (the source has no predecessor), butp[v]= the origin of thered edgesfor the rest, e.g.,p[2]= 0,p[4] = 2.
Thus, if we are ats= 0 and want to go to vertex 4, we will use shortest path 0 → 2 → 4 with path weight 7. In the exploration mode, after any SSSP algorithm has been completed, you can hover on any vertex and notice the shortest path from source vertexsto that vertex is highlighted.
Some graphs containnegative weight edge(s)(not necessarily cyclic) and/ornegative weight cycle(s). For example (fictional): Suppose you can travel forward in time (normal, edges with positive weight) or back in time by passing through time tunnel (special wormhole edges with negative weight), as the example shown above.
On that graph, the shortest paths from the source vertexs= 0 to vertices {1, 2, 3} are allill-defined. For example 1 → 2 → 1 is a negative weightcycleas it has negative total path (cycle) weight of 15-42 = -27. Thus we can cycle around that negative weight cycle 0 →1 → 2 → 1 → 2→ ... forever to get overall ill-defined shortest path weight of -∞.
However, notice that the shortest path from the source vertexs= 0 to vertex 4 is ok with δ(0, 4) = -99. So the presence of negative weightedge(s)is not themainissue. The main issue is the presence of negative weightcycle(s)reachable from source vertexs.
The main operation for all SSSP algorithms discussed in this visualization is therelax(u, v, w(u, v))operation with the following pseudo-code:
relax(u, v, w_u_v)if D[v] > D[u]+w_u_v // if the path can be shortenedD[v] = D[u]+w_u_v // we 'relax' this edgep[v] = u // remember/update the predecessor// update some other data structure(s) as necessary
For example, seerelax(1,2,4)operation on the figure below:
There are four different sources for specifying an input graph:
Edit Graph: You can edit or (re-)draw currently shown directed weighted graph.
Input Graph: You can input a graph (in Edge List/Adjacency List/Adjacency Matrix format) and VisuAlgo will propose a 2D graph drawing for your graph.
Example Graphs: You can select from the list of our selected example graphs to get you started. These example graphs have different characteristics.
NEW (Oct 24): An NUS student created the followingmaze/grid-based graphdrawing tool that can be quickly used to create a maze/grid graph that can be exported back to this sssp visualization page.
In this visualization, we will discuss 6 (SIX) SSSP algorithms.
We will start with the O(V×E) Bellman-Ford algorithm first as it is the most versatile (but also the slowest) SSSP algorithm. We will then discuss 5 (FIVE) other algorithms (including two variants of Dijkstra's algorithm) that solvespecial-casesof SSSP problem in a much faster manner.
The general purposeBellman-Ford algorithmcan solveall kindsof valid SSSP problem variants (expect one — the one that is ill-defined anyway, to be discussed soon), albeit with arather slowO(V×E) running time. It also has an extremely simple pseudo-code:
for i = 1 to |V|-1 // O(V) here, so O(V×E×1) = O(V×E)for each edge(u, v) ∈ E // O(E) here, e.g. by using an Edge Listrelax(u, v, w(u, v)) // O(1) here
Without further ado, let's see a preview of how it works on the example graph above by clickingBellmanFord(0)(≈30s, and for now, please ignore the additional loop at the bottom of the pseudo-code).
Bellman-Ford algorithm can be made to run slightly faster on normal input graph, from the worst case of O(V×E) to just O(k×E) wherekis the number of iterations of the outer loop of Bellman-Ford.
Discussion: How to do this? Is the speed-up significant?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
To convince the worldwide audience that Bellman-Ford algorithm works, let's temporarily move from visualization mode to proof mode for a few slides.
Theorem 1: If G = (V, E) containsno negative weight cycle, then the shortest pathpfrom source vertexsto a vertexvmust be asimple path.
Recall: A simple path is a pathp = {v0, v1, v2, ..., vk}, (vi,vi+1) ∈E, ∀ 0 ≤i≤ (k-1) and there isnorepeated vertex along this path.
Suppose the shortest pathpisnota simple path
Thenpmust contains one (or more) cycle(s) (by definition of non-simple path)
Suppose there is a cyclecinpwithpositive weight(e.g.,green→blue→greenon the left image)
If we removecfromp, then we will have a shorter 'shortest path' than our shortest pathp
A glaring contradiction, sopmust be a simple path
Even ifcis actually a cycle withzero (0) total weight— it is possible according to our Theorem 1 assumption: no negative weight cycle (see the samegreen→blue→greenbut on the right image), we can still removecfrompwithout increasing the shortest path weight ofp
In conclusion,pis a simple path (from point 5) or can always be made into a simple path (from point 6)
In another word, shortest pathphas at most |V|-1 edges from the source vertexsto the 'furthest possible' vertexvinG(in terms of number of edges in the shortest path — see the Bellman-Ford Killer example above).
Theorem 2: If G = (V, E) containsno negative weight cycle, then after Bellman-Ford algorithm terminates, we will haveD[u]=δ(s, u), ∀u∈V.
For this, we will useProof by Inductionand here are the starting points:
Consider the shortest pathpfrom source vertexsto vertexviwhereviis defined as a vertex which the actual shortest path to reach it requiresihops (edges) from source vertexs. Recall from Theorem 1 thatpwill be simple path as we have the same assumption ofno negative weight cycle.
Initially,D[v0] = δ(s, v0) = 0, as v0is just the source vertexs
After1pass throughE, we haveD[v1] = δ(s, v1)
After2pass throughE, we haveD[v2] = δ(s, v2)
...
Afterkpass throughE, we haveD[vk] = δ(s, vk)
When there is no negative weight cycle, the shortest pathpis a simple path (see Theorem 1), thus the last iteration should be iteration |V|-1
After |V|-1 pass throughE, we haveD[v|V|-1] = δ(s, v|V|-1), regardless the ordering of edges inE— see the Bellman-Ford Killer example above
Try runningBellmanFord(0)on the 'Bellman-Ford Killer' example above. There areV= 7 vertices andE= 6 edges but the edge listEis configured to be at its worst possible order. Notice that after (V-1)×E= (7-1)*6 = 36 operations (~40s, be patient), Bellman-Ford will terminate with the correct answer and there is no way we can terminate Bellman-Ford algorithm earlier.
The only input graph that Bellman-Ford algorithm has issue is the input graph with negative weight cycle reachable from the source vertexs.
However, Bellman-Ford can be used to detect if the input graph contains at least one negative weight cycle reachable from the source vertexsby using the corollary of Theorem 2: If at least one valueD[u]fails to converge after |V|-1 passes, then there exists a negative-weight cycle reachable from the source vertexs.
Now runBellmanFord(0)on the example graph that contains negative edges and a negative weight cycle. Please concentrate on the loop at the bottom of the pseudo-code.
Sometimes, the actual problem that we face isnot the general formof the original problem. Therefore in this e-Lecture, we want to highlight five (5) special cases involving the SSSP problem. When we encounter any one of them, we can solve it withdifferentand(much) fasteralgorithm than the generic O(V×E) Bellman-Ford algorithm. They are:
On Unweighted Graphs: O(V+E) BFS,
On Graphs without negative weight: O((V+E) logV) Dijkstra's algorithm,
On Graphs without negative weight cycle: O((V+E) logV) Modified Dijkstra's,
On Tree: O(V+E) DFS/BFS,
On Directed Acyclic Graphs (DAG): O(V+E) Dynamic Programming (DP)
The O(V+E)Breadth-First Search (BFS)algorithm can solvespecial caseof SSSP problem when the input graph isunweighted(all edges have unit weight 1, tryBFS(5)on example: 'CP4 4.2 U/U' above) orpositive constant weighted(all edges have the same constant weight, e.g. you can changealledge weights of the example graph above with any positive constant weight of your choice).
When the graph isunweighted— this appears quite frequently in real life — the SSSP problem can be viewed as a problem of finding theleast number of edgestraversed from the source vertexsto other vertices.
The BFS spanning tree from source vertexsproduced by the fast O(V+E) BFS algorithm — notice the + sign — precisely fits the requirement.
Compared with the O(V×E) of Bellman-Ford — notice the × sign — it is a no-brainer to use BFS for this special case of SSSP problem.
Compared to the standard BFS inGraph Traversalmodule, we need to perform simple modifications to make BFS able to solve the unweighted version of the SSSP problem:
First, we change the Boolean arrayvisitedinto an Integer arrayD.
At the start of BFS, instead of settingvisited[u] = false, we setD[u] = 1e9(a large number to symbolise +∞ or even -1 to symbolise 'unvisited' state, but we cannot use 0 asD[0] = 0) ∀u∈V\{s}; Then we setD[s] = 0
We change the BFS main loop fromif (visited[v] = 0) { visited[v] = 1 ... } // v is unvisitedtoif (D[v] = 1e9) { D[v] = D[u]+1 ... } // v is 1 step away from u
However, BFS will very likely produce wrong answer when run on weighted graphs as BFS is not actually designed for to solve the weighted version of SSSP problem. There may be a case that taking a path with more number of edges used produces lower total overall path weight than taking a path with minimum number of edges used — which is the output of BFS algorithm.
In this visualization, we will allow you to run BFS even on 'wrong' input graph for pedagogical purpose, but we will display awarning messageat the end of the algorithm. For example, tryBFS(0)on the general graph above and you will see that vertices {3,4} will have wrong D[3] and D[4] values (and also p[3] and p[4] values).
We will soon see Dijkstra's algorithm (2 implementation variants) for solving certain weighted SSSP problems in a faster way than the general Bellman-Ford algorithm.
The O((V+E) logV)Dijkstra's algorithmis the most frequently used SSSP algorithm for typical input: Directed weighted graph that hasno negative weight edge, formally:∀edge(u, v) ∈ E,w(u, v) ≥ 0. Such weighted graph (especially the positive weighted ones) is very common in real life as travelling from one place to another always use positive time unit(s). TryDijkstra(0)on one of the Example Graphs: CP4 4.16* D/W shown above (compared to CP4 version, we add one more edge 2 → 1 to make the graph non-DAG).
Dijkstra's algorithm maintains a setR(esolved) — other literature use setS(olved) but setSand source vertexsare too close when pronounced — of vertices whose final shortest path weights have been determined. InitiallyR={}, empty.
Then, it repeatedly selects vertexuin{V\\R}(can also be written as{V-R}) with the minimum shortest path estimate (the first vertex selected isu = sas initially onlyD[s] = 0and the other vertices haveD[u] = ∞), addsutoR, and relaxes all outgoing edges ofu. Detailed proof of correctness of this Dijkstra's algorithm is usually written in typical Computer Science algorithm textbooks and we replicate it in the next few slides. For a simpler intuitive visual explanation on why this greedy strategy works, seethis.
For efficient implementation, this entails the use of a Priority Queue as the shortest path estimates keep changing as more edges are processed. The choice of relaxing edges emanating from vertex with the minimum shortest path estimate first isgreedy, i.e., use the "best so far", but we will see later that it can be proven (with loop invariants) that it will ends up with an optimal result — if the graph has no negative weight edge.
In Dijkstra's algorithm, each vertex will only be extracted from the Priority Queue (PQ) once. As there areVvertices, we will do this maximum O(V) times.
ExtractMin() operation runs in O(logV) whether the PQ is implemented using aBinary Min Heapor using abalanced BST like AVL Tree.
Therefore this part is O(VlogV).
Every time a vertex is processed, we relax its neighbors. In total,Eedges are processed.
If by relaxingedge(u, v), we have to decreaseD[v], we call the O(logV) DecreaseKey() operation inBinary Min Heap(harder to implement as C++ STL priority_queue/Python heapq/Java PriorityQueue does not support this operation efficientlyyet) or simply delete the old entry and then re-insert a new entry inbalanced BST like AVL Tree(which also runs in O(logV), but this is much easier to implement, just use C++ STL set/Java TreeSet — unfortunately not natively supported in Python).
Therefore, this part is O(ElogV).
Thus in overall, Dijkstra's algorithm runs in O(VlogV+ElogV) = O((V+E) logV) time, which is much faster than the O(V×E) Bellman-Ford algorithm.
To show the correctness of Dijkstra's algorithm on non-negative weighted graph, we need to useloop invariant: a condition which is True at the start of every iteration of the loop.
We want to show:- Initialization: The loop invariant is true before the first iteration.- Maintenance: If the loop invariant is true for iteration x, it remains true for iteration x+1.- Termination: When the algorithm ends, the loop invariant helps the proof of correctness.
Discussion: Formally prove the correctness of Dijkstra's algorithm in class!
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
When the input graph contains at least one negative weight edge — not necessarily negative weight cycle — Dijkstra's algorithm can produce wrong answer.
TryDijkstra(0)on one of the Example Graphs: CP4 4.20.
At the end of the execution of Dijkstra's algorithm, vertex 4 has wrong D[4] value as the algorithm started 'wrongly' thinking that subpath 0 → 1 → 3 is the better subpath of weight 1+2 = 3, thus making D[4] = 6 after callingrelax(3,4,3). However, the presence of negative weight -10 at edge 2 → 3 makes the other subpath 0 → 2 → 3 eventually the better subpath of weight 10-10 = 0 although it started worse with path weight 10 after the first edge 0 → 2. This better D[3] = 0 is never propagated further due to the greedy nature of Dijkstra's algorithm, hence D[4] is wrong.
Dijkstra's algorithm can also be implemented differently. The O((V+E) logV)Modified Dijkstra's algorithmcan be used for directed weighted graphs that may have negative weight edges but no negative weight cycle.
Such input graph appears in some practical cases, e.g., travelling using anelectric carthat has battery and our objective is to find a path from source vertexsto another vertex that minimizes overallbattery usage. As usual, during acceleration (or driving on flat/uphill road), the electric caruses(positive) energy from the battery. However, during braking (or driving on downhill road), the electric carrecharges(or use negative) energy to the battery. There is no negative weight cycle due to kinetic energy loss.
For example, tryModifiedDijkstra(0)on one of the Example Graphs: CP4 4.20 that has troubled the original version of Dijkstra's algorithm (seeprevious slide).
The key idea is the 'usage modification' done to C++ STL priority_queue/Python heapq/Java PriorityQueue to allow it to perform the required 'DecreaseKey' operation efficiently, i.e., in O(logV) time.
The technique is called 'Lazy Update' where we leave the 'outdated/weaker/bigger-valued information' in the Min Priority Queue instead of deleting it straight-away. As the items are ordered from smaller values to bigger values in a Min PQ, we are guaranteeing ourself that we will encounter the smallest/most-up-to-date item first before encountering the weaker/outdated item(s) later - which by then can be easily ignored.
On non-negative weighted graphs, the behavior of Modified Dijkstra's implementation is exactly the same as the Original Dijkstra's so we can use the same time complexity analysis of O((V+E) logV).
PS: We note that when we use the Modified Dijkstra's algorithm, there can be more items (up toE) in the Priority Queue than if we use the Original Dijkstra's algorithm (up toV). However, since O(logE) = O(logV^2) = O(2 logV) = O(logV), we still treat the Priority Queue operations as O(logV).
However, if the graph has at least one negative weight edge, the analysis is harder.
When the input graph contains at least one negative weight edge but no negative weight cycle — the modified Dijkstra's algorithm produces correct answer.
TryModifiedDijkstra(0)on one of the Example Graphs: CP4 4.20 that causes problem forDijkstra(0).
At the end of the execution of ModifiedDijkstra's algorithm, vertex 4 has correct D[4] value as although the modified Dijkstra's algorithm also started 'wrongly' thinking that subpath 0 → 1 → 3 is the better subpath of weight 1+2 = 3, thus making D[4] = 6 after callingrelax(3,4,3). Here, the modified Dijkstra's algorithmcontinuespropagating D[3] = 0 after it founds out that the other subpath 0 → 2 → 3 is eventually the better subpath of weight 10-10 = 0. Hence D[4] is eventually correct again. However, this is at the expense of potentially running (much more) operations than O((V+E) logV).
Unfortunately, runningModifiedDijkstra(0)on the graph with negative weight cycle as shown on one of the Example Graphs: CP4 4.22 above will cause an endless loop (the animation is very long but we limit the number of loop to be 100 edges processed so your web browser will not hang).
TryModifiedDijkstra(0)on the extreme corner case above that is very hard to derive without proper understanding of this algorithm and was part of Asia Pacific Informatics Olympiad (APIO) 2013 task set by A/P Halim himself long ago.
The Modified Dijkstra's algorithm will terminate with correct answer, but only after running exponential number of operations (each carefully constructed triangle raises the number of required operations by another power of two). Thus we cannot prematurely terminate Modified Dijkstra's in this worst case input situation.
However, such extreme corner case is rare and thus in practice, Modified Dijkstra's algorithm can be used on directed graphs that havesomenegative weighted edges as long as the graph has no negative weight cycle reachable from the source vertexs.
The O(V)Depth-First Search (DFS)algorithm can solvespecial caseof SSSP problem, i.e. when the input graph is a (weighted)Tree.
In a Tree, there is only one unique and acylic path that connects two distinct vertices. Thus the unique path that connects the source vertexsto any another vertexu∈Vis actually also the shortest path. For example, tryDFS(0)on the Tree above.
Notice that for a (weighted) Tree, we can also use BFS. For example, tryBFS(0)on the same Tree above.
Discussion: Why DFS (and also BFS) runs in O(V) instead of O(V+E) if the input is a (weighted) Tree?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
DFS will very likely produce wrong answer when run on any other graph that is not a Tree. We will display awarning messagefor such cases although we do not prevent you from trying this feature for pedagogical purpose.
For example, tryDFS(0)on the general graph above and you will see that vertex {4} will have wrong D[4] value (and also wrong p[4] value) as DFS(0) goes deep 0 → 1 → 3 → 4 first, backtrack all the way to vertex 0 and eventually visit 0 → 2 but edge 2 → 4 cannot be processed as vertex 4 has been visited by DFS earlier.
The O(V+E)Dynamic Programmingalgorithm can solvespecial caseof SSSP problem, i.e. when the input graph is aDirected Acyclic Graph (DAG)thus we can find at least one topological order of the DAG and process the edge relaxation according to this topological order.
For example, tryDP(0)on the example DAG above. First, it computes one (there are other) possible topological order using either the O(V+E) DFS or the BFS/Kahn's algorithm outlined inGraph Traversalmodule. For example, assume one topological order is {0,2,1,3,4,5}. Then, it relaxes the outgoing edges of vertices listed in that topological order. After just one O(V+E) pass, we will have correctD[u]values ∀u∈V.
On the Modified Dijkstra's killer example shown above,DP(0)works fast as the graph is actually a DAG, albeit having negative weight edge. As the graph is a DAG, there will not be any negative weight cycle to worry about.
However, DP will not work for any non DAG as non DAG contains at least one cycle and thus no topological order can be found within that cycle.
DP algorithm for solving SSSP on DAG is also calledone-passBellman-Ford algorithm as it replaces the outermostV-1 loop (we do not know the correct order so we just repeat until the maximum possible) with just one topological order pass (we know that this is (one of) the correct order(s) of this DAG).
CompareDP(0)(relaxEedges just once — according to topological order of its vertices) versusBellmanFord(0)(relaxEedges in random order,V-1 times) on the same example DAG above.
We have lots of other stuffs on top of this basic explanation of SSSP algorithms for SSSP problems.
Meanwhile, you are allowed to use/modify our implementation code for Bellman-Ford/Bellman-Ford-Moore/Dijkstra's Algorithms:bellman_ford.cpp/bellman_ford_moore.cpp/dijkstra.cppbellman_ford.java/bellman_ford_moore.java/dijkstra.javabellman_ford.py/bellman_ford_moore.py/dijkstra.pybellman_ford.ml/bellman_ford_moore.ml/dijkstra.ml
For a few more interesting questions about this SSSP problem and its various algorithms, please practice onSSSPtraining module (no login is required).
However, for registered users, you should login and then go to theMain Training Pageto officially clear this module (after clearing the other pre-requisites modules) and such achievement will be recorded in your user account.
We also have a few programming problems that somewhat requires the usage of the correct SSSP algorithm:Kattis - hidingplacesandKattis - shortestpath1.
Try to solve them and then try themany moreinteresting twists/variants of this interesting SSSP problem.
Advertisement:Buy Competitive Programming textbookto read more on this interesting problem.
You have reached the last slide. Return to 'Exploration Mode' to start exploring!
Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.
Edit Graph
Input Graph
Example Graphs
BellmanFord(s)
BFS(s)
Dijkstra(s)
DFS(s)
DP(s)
Unweighted
House of Cards D/U
CP4 4.7 D/U
CP4 4.3 D/U (DAG)
CP4 4.2 U/U
CP4 4.1 U/U
Weighted
Wheel Graph
Zig-Zag
Big
CP4 4.16* D/W
CP4 4.14 D/W
CP4 4.10 D/W
Large
MRT
Negative Weight
CP4 4.22 -ve cycle
CP4 4.20 -ve weight (DAG)
Corner Case
Bellman-Ford Killer
CP4 4.21 (Dijkstra's Killer)
Special Case
CP4 4.36 Tree
CLRS 22.5 (with curvy edges)
Another DAG
RAIL (DAG)
Bellman-Ford
Bellman-Ford-Moore
Go
Original
Modified
Go
Go
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
Maximum (Max) Flow is one of the problems in the family of problems involving flow in networks.
In Max Flow problem, we aim to find the maximum flow from a particular source vertexsto a particular sink vertextin a directed weighted graphG.
There are several algorithms for finding the maximum flow including Ford-Fulkerson method, Edmonds-Karp algorithm, and Dinic's algorithm (there are a few others, but they are not included in this visualization yet).
The dual problem of Max Flow is Min Cut, i.e., by finding the maxs-tflow ofG, we also simultaneously find the mins-tcut ofG, i.e., the set of edges with minimum weight that have to be removed fromGso that there is no path fromstotinG.
Remarks: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.If you are an NUS student and a repeat visitor, pleaselogin.
Max-Flow (or Min-Cut) problems arise in various applications, e.g.,
Transportation-related problems (what is the best way to send goods/material froms(perhaps a factory) tot(perhaps a super-sink of all end-users)
Network attacks problems (sabotage/destroy some edges to disconnect two important pointssandt)
(Bipartite) Matching and Assignment problems (that also has specialized algorithms, seeGraph Matchingvisualization
Sport teams prospects
Image segmentation, etc...
Pro-tip 1: Since you are notlogged-in, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode:[PageDown]/[PageUp]to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use[→ or ↓/← or ↑]to do the same),and[Esc]to toggle between this e-Lecture mode and exploration mode.
This visualization page will show the execution of a chosen Max Flow algorithm running on a flow (residual) graph.
To make the visualization of these flow graphs consistent, we enforce a graph drawing rule for this page whereby the source vertexs/sink vertextis always vertex 0/V-1 and is always drawn on the leftmost/rightmost side of the visualization, respectively. Another visualization-specific constraint is that the edge capacities are integers between [1..99].
These visualization-specific constraints donotexist in the standard max flow problems.
Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolutionor larger(typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (F11) to enjoy this setup. However, you can use zoom-in (Ctrl +) or zoom-out (Ctrl -) to calibrate this.
The input for a Max Flow algorithm is a flow graph (adirected weightedgraphG=(V, E)where edge weight of edgeerepresent the capacityc(e)(the unit is problem-dependent, e.g., liters/second, person/hour, etc) of flow that can go through that edge) with two distinguished vertices: The source vertexs(with in-degree 0) and the sink/target/destination vertext(with out-degree 0). The flow graph is usuallys-tconnected, i.e., there is at least one path fromstot(otherwise the max flow is trivially 0).
In this visualization, these two additional inputs ofs(usually vertex 0) andt(usually vertexV-1) are asked before the execution of the chosen Max Flow algorithm and can be customized by the user.
Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode):Spacebarto play/pause/replay the animation,←/→to step the animation backwards/forwards, respectively, and-/+to decrease/increase the animation speed, respectively.
The output for a Max Flow algorithm is the max flow value and an assignment of flowfto each edge that satisfies two important constraints:
Capacity constraints(flow on each edge (f(e)) is between 0 and its (unit) capacity (c(e)), i.e., 0 ≤f(e)≤c(e)— not negative and not more than the capacity), and
Equilibrium constraints(for every vertex exceptsandt, flow-in = flow-out)
In this visualization, we focus on showing the final max flow value and the final ST-min cut components at the end of each max flow algorithm execution, instead of the precise assignment of flowfto each edge, i.e.,f(e)must be computed manually from the initial capacityc(e)(first frame of the animation) minus the final residual capacity of that edgee(last frame of the animation). This missing feature will likely be added in the next iteration of this visualization page.
Discussion: Is there other ways to compute the value of the flowvalue(f)?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
At the start of the three Max Flow algorithms discussed in this visualization (Ford-Fulkerson method, Edmonds-Karp algorithm, and Dinic's algorithm), the initial flow graph is converted into residual graph (with potential addition of back flow edges with initial capacity of zeroes).
The edges in the residual graph store theremainingcapacities of those edges that can be used by future flow(s). At the beginning, these remaining capacities equal to the original capacities as specified in the input flow graph.
A Max Flow algorithm will send flows to use some (or all) of these available capacities, iteratively.
Once the remaining capacity of an edge reaches 0, that edge can no longer admit any more flow. In the near future, we will update this visualization so that any edge in the residual graph that has capacity 0 (including the initial zeroes of the back flow edges) isnotshown in the visualization.
There are three different sources for specifying an input flow graph:
Draw Graph: You can drawanydirected weighted (weight ∈ [1..99]) graph as the input flow graph with vertex 0 as the default source vertex (the left side of the screen) and vertexV-1 as the default sink vertex (the right side of the screen),
Modeling: Several graph problems can be reduced into a Max Flow problem. In this visualization, we have the modeling examples for the famous Maximum Cardinality Bipartite Matching (MCBM) problem, Rook Attack problem (currently disabled), and Baseball Elimination problem (currently disabled),
Example Graphs: You can select from the list of our selected example flow graphs to get you started.
There are three different max flow algorithms in this visualization:
The slow O(mf × E)Ford-Fulkersonmethod,
The O(V × E^2)Edmonds-Karpalgorithm, or
The O(V^2 × E)Dinic'salgorithm.
There are a few othermax flow algorithmsout there, but they are not available in this visualization yet.
For the three Max Flow algorithms discussed in this visualization, successive flows are sent from the source vertexsto the sink vertextvia availableaugmenting paths(augmenting path is a path fromstotthat goes through edges with positive weight residual capacity (c(e)-f(e)) left).
The three Max Flow algorithms in this visualization have different behavior on how they find augmenting paths.
However, all three Max Flow algorithms in this visualization stop when there is no more augmenting path possible and report the max flow value (and the assignment of flow on each edge in the flow graph).
Later we will discuss that this max flow value is also the min cut value of the flow graph (that famous Max-Flow/Min-Cut Theorem).
start with 0 flowwhile there exists an augmenting path: // iterative algorithmfind an augmenting path (for now, 'any' graph traversal will do)compute bottleneck capacityincrease flow on the path by the bottleneck capacity
This famous theorem states that in a flow network, themaximum flowfromstotis equal to the total weight of the edges in aminimum cut, i.e., the smallest total weight of the edges that have to be removed to disconnectsfromt.
In a typical Computer Science classes, the lecturer will usually spend some time to properly explain this theorem (explaining what is an st-cut, capacity of an st-cut, net flow across an st-cut equals to current flow f assignment that will never exceed the capacity of the cut, and finally that Max-Flow/Min-Cut Theorem). For this visualization, we just take this statement as it is.
Discussion: For live class in NUS, we will actually discuss these theorem.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Using the Max-Flow/Min-Cut Theorem, we can then prove that flowfis a maximum flow if and only if there is no (more) augmenting path remaining in the residual graph.
As this is what Ford-Fulkerson Method is doing, we can conclude the correctness of this Ford-Fulkerson Method, i.e., if Ford-Fulkerson Method terminates, then there is no augmenting path left and thus the resulting flow is maximum (and we can also construct the equivalent Min-Cut, next slide).
We can constructively identify the edges in the Min-Cut as follows:
Run Ford-Fulkerson (or any other Max Flow) algorithm until it terminates.
LetSbe the set of vertices that are still reachable from the sources.We can run DFS (or BFS) in the residual graph from the source vertexs.All the vertices that are still reachable are inS.LetTbe the remaining vertices, i.e.,T = V \ S.
For every edge inS, enumerate outgoing edges:If edge exitsS(and intoT), add to min-cut.If both ends of edge are inS, then continue.
That's it,(S,T)is an st-cut, edges from (S → T) are the minimum cut, and the flow that goes through this minimum cut(S,T)is the maximum possible.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Ford-Fulkerson method always terminates if the capacities are integers.
This is because every iteration of Ford-Fulkerson method always finds a new augmenting path and each augmenting path must has bottleneck capacity at least 1 (due to that integer constraint). Therefore, each iteration increases the flow of at least one edge by at least 1, edging the Ford-Fulkerson closer to termination.
As the number of edges is finite (as well as the finite max capacity per edge), this guarantees the eventual termination of Ford-Fulkerson method when the max flowmfis reached and there is no more augmenting path left.
In the worst case, Ford-Fulkerson method runs formfiterations, and each time it uses O(E) DFS. The rough overall runtime is thus O(mf × E) — this is actually not desirable especially if the value ofmfis a huge number.
Discussion: What if the capacities are rational numbers? What if the capacities are floating-point numbers?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Idea: What if we don't consideranyaugmenting paths but consider augmenting paths with the smallest number of edges involved first (so we don't put flow on more edges than necessary).
Implementation: We first ignore capacity of the edges first (assume all edges in the residual graph have weight 1), and we run O(E) BFS to find the shortest (in terms of # of edges used) augmenting path. Everything else is the same as the basic Ford-Fulkerson Method outlined earlier.
It can be proven that Edmonds-Karp will use at most O(VE) iterations thus it runs in at most in O(VE * E) = O(VE^2) time.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Dinic's algorithm also uses similar strategy of finding shortest augmenting paths first.
But Dinic's algorithm runs in a faster time of O(V^2 × E) due to the more efficient usage of BFS shortest path information.
This slide will be expanded.
When you are presented with a Max Flow (or a Min Cut)-related problem, we do not have to reinvent the wheel every time.
You are allowed to use/modify/adapt/enhance our implementation code for Max Flow Algorithms (Edmonds-Karp/Dinic's):maxflow.cpp|py|java|ml.
You have reached the last slide. Return to 'Exploration Mode' to start exploring!
Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.
Edit Graph
Input Graph
Modeling
Example Graphs
Ford-Fulkerson
Edmonds-Karp
Dinic
Min-Cost-Max-Flow
Bipartite Matching
all 1
right 1
left 1
random
Corner Case
CP4 Ex 8.5.3.1* (correct)
CP4 Ex 8.5.3.1* (wrong)
CP4 8.11* (FF Killer)
Special Case
CP4 8.17.C*
CP4 8.17.B* (MC T = {t})
CP4 8.17.A* (MC S = {s})
CS4234 MF Demo
CP4 8.15* (Dinic Showcase)
Matching with Capacity
waif (AC)
Reduction
CP4 8.29* (MWVC)
CP4 8.20.B* (MEDP)
CP4 8.20.A* (MVDP/MIP)
MCMF
CP4 9.24 UVa 10746
CP4 9.23
Go
Go
Go
Go
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
AMatchingin a graphG = (V, E)is a subset of edgesMof a graphG = (V, E)such that no two edges share a common vertex.
Maximum Cardinality Matching (MCM)problem is a Graph Matching problem where we seek a matchingMthat contains the largest possible number of edges. A desirable but rarely possible result isPerfect Matchingwhere all |V| vertices are matched (assuming |V| is even), i.e., the cardinality ofMis |V|/2.
ABipartite Graphis a graph whose vertices can be partitioned into two disjoint setsUandVsuch that every edge can only connect a vertex inUto a vertex inV.
Maximum Cardinality Bipartite Matching (MCBM)problem is theMCMproblem in a Bipartite Graph, which is a lot easier thanMCMproblem in a General Graph.
Remarks: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.If you are an NUS student and a repeat visitor, pleaselogin.
Graph Matching problems (and its variants) arise in various applications, e.g.,
Matching job openings (one disjoint set) to job applicants (the other disjoint set)
The weighted version of #2 is called theAssignment problem
Special-case of some NP-hard optimization problems(e.g.,MVC, MIS, MPC on DAG, etc)
Deterministic 2-opt Approximation Algorithm forMVC
Sub-routine of Christofides's 1.5-approximation algorithm forTSP, etc...
Pro-tip 1: Since you are notlogged-in, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode:[PageDown]/[PageUp]to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use[→ or ↓/← or ↑]to do the same),and[Esc]to toggle between this e-Lecture mode and exploration mode.
In some applications, the weights of edges are not uniform (1 unit) but varies, and we may then want to take MCBM or MCM with minimum (or even maximum) total weight.
This visualization support both unweighted and weighted MCBM, but only works for unweighted MCM.
We do not have immediate plan to add support for weighted MCM and only rely on Dynamic Programming with Bitmask for small graphs solution.
Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolutionor larger(typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (F11) to enjoy this setup. However, you can use zoom-in (Ctrl +) or zoom-out (Ctrl -) to calibrate this.
To switch between the unweightedMCBM(default, as it is much more popular), weightedMCBM, and unweightedMCMmode, click the respective header.
Here is an example ofMCMmode. InMCMmode, one can draw aGeneral, not necessarilyBipartitegraphs. However, the graphs are unweighted (all edges have uniform weight 1).
The available algorithms (and example graphs) are different in each mode.
Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode):Spacebarto play/pause/replay the animation,←/→to step the animation backwards/forwards, respectively, and-/+to decrease/increase the animation speed, respectively.
You can view the visualisation here!
ForBipartite Graphvisualization, we will mostly layout the vertices of the graph so that the two disjoint sets (UandV) are clearly visible as Left (U) and Right (V) sets. When you draw your input bipartite graph, you can choose to re-layout your bipartite graph into this easier-to-visualize form. However, you do not have to visualize Bipartite Graph in this form, e.g., you can clickGrid Graphto load an example grid graph and notice that vertices {0,1,2,3} can form setUand vertices {4,5,6,7,8} can form setV. There is no odd-length cycle in this grid graph.
ForGeneral Graph, we do not (and usually cannot) re-layout the vertices into this Left Set and Right Set form.
Initially, edges havegreycolor. Matched edges will haveblackcolor. Free/Matched edges along an augmenting path will haveOrange/Light Bluecolors, respectively.
There are four different sources for specifying an input graph:
Edit Graph: You can drawanyundirected unweighted graph as the input graph.However, due to the way we visualize our MCBM algorithms, we need to impose one additional graph drawing constraint that does not exist in the actual MCBM problems. That constraint is that vertices on the left set are numbered from [0, n), and vertices on the right set are numbered from [n, n+m). You do not have to visually draw them in left-right sets form, as shown in thisGrid Graphexample.
Input Graph: This is a new (not fully tested) feature.
Modeling: Several graph problems can be reduced into anMCBMproblem. In this visualization, we have the modeling examples for the famous Rook Attack problem and standardMCBMproblem (also valid inMCMmode).
Example Graphs: You can select from the list of our example graphs to get you started. The list of examples is slightly different in the twoMCBMvsMCMmodes.
This slide is a stub and will be expanded with the explanation of this problem and how to interpret the bipartite graph created.
You can create any (small) bipartite graph withn/mvertices on the left set, respectively, and set the density of the edges, with 100% being a complete bipartite graphKn,mand 0% being a bipartite graph with no edge.
There are several Max Cardinality Bipartite Matching (MCBM) algorithms in this visualization, plus one more in Max Flow visualization:
By reducing MCBM problem into a Max-Flow problem in polynomial time,we can actually use any Max Flow algorithm to solve MCBM.
O(VE)Augmenting Path Algorithm(without greedy pre-processing),
O(√(V)E)Dinic'sorHopcroft-Karp Algorithm,
O(kE)Augmenting Path Algorithm(with randomized greedy pre-processing),
PS1: Although possible, we will likely not use O(V3)Edmonds' Matching Algorithmif the input is guaranteed to be aBipartite Graph(as it is much slower).
PS2: Although possible, we will also likely not use O(V3)Kuhn-Munkres Algorithmif the input is guaranteed to be anunweightedBipartite Graph (again, as it is much slower).
TheMCBMproblem can be modeled (or reduced into) as a Max Flow problem in polynomial time.
Go toMax Flowvisualization page and see the flow graph modeling of MCBM problem (select Modeling → Bipartite Matching → all 1). Basically, create a super source vertexsthat connects to all vertices in the left set and also create a super sink vertextwhere all vertices in the right set connect tot. Keep all edges in the flow graphdirectedfrom source to sink and with unit weight 1.
If we use one of the earliest Max Flow algorithm, i.e., a simple Ford-Fulkerson algorithm, the time complexity will be tighter than O(mf × E) as all edge weights in the flow graph are unit weight somf ≤ V, i.e., so O(V × E) overall.
If we use one of the fastest Max Flow algorithm, i.e., Dinic's algorithm on this flow graph, we can find Max Flow = MCBM in O(√(V)E) time —the analysis is omitted for now. This allows us to solve MCBM problem withV∈ [1000..1500] in a typical 1s allowed runtime in many programming competitions.
Discussion: Must the edges in the flow graph be directed or can they be undirected? Explain.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Actually, we can just stop here, i.e., when given any MCBM(-related) problem, we can simply reduce it into a Max-Flow problem and use (the fastest) Max Flow algorithm.
However, there is a far simpler Graph Matching algorithm that we will see in the next few slides. It is based on a crucial theorem and can be implemented as an easy variation of the standard Depth-First Search (DFS) algorithm.
Augmenting Pathis a path that starts from a free (unmatched) vertexuin graphG(note thatGdoes not necessarily has to be a bipartite graph although augmenting path, if any, is much easier to find in a bipartite graph), alternates through unmatched (or free/'f'), matched (or 'm'), ..., unmatched ('f') edges inG, until it ends at another free vertexv. The pattern of any Augmenting Path will be fmf...fmf and is of odd length.
If we flip the edge status along that augmenting path, i.e., fmf...fmf into mfm...mfm, we will increase the number of edges in the matching setMby exactly 1 unit and eliminates this augmenting path.
In 1957, Claude Berge proposes the followingtheorem:A matchingMin graphGis maximum iff there is no more augmenting path in G.
Discussion: In class, prove the correctness of Berge's theorem!In practice, we can justuse it verbatim.
The proof claims if and only if, thus it has two parts:the forwards direction and the backwards direction.
The forwards proof is easier:M∈Gis maximum → there is no augmenting path inGw.r.tM.
The backwards proof is a bit harder:M∈Gis maximum ← there is no augmenting path inGw.r.tM.
Proof by contradiction:SupposeM∈Gis maximum butGstill hasan augmenting path w.r.t matchingM.
Now, this augmenting path: fmf...fmf (which has odd length) can be flipped into another matchingM'that drops the previously matched edges (the 'm's) and takes theotherfree edges (the 'f's) along the augmenting path. Thus, making|M'| = |M|+1.
This contradicts the statement thatMis maximum matching.
So, ifM∈Gis maximum → there is no more augmenting path w.r.t matchingMin G.
This part is usually challenging to be understood in one go. Please read carefully.
We use proof by contradiction again:Suppose there is no augmenting path inGw.r.tMbutM∈Gis not maximum,i.e., we haveM'that is larger thanM.
First, we take asymmetric differenceofM'andMto produce a new graphG'that has the same vertices asG, but only edges that are involved in eitherM'orM(but not both).
Let's observe this new graphG'. Notice thatG'will only consist of vertices with degree 0 (isolated vertices, we ignore them), degree 1 (endpoint of an augmenting path), or degree 2 (in the middle of augmenting path, a vertex that connects an edge inMand another edge inM'). Graph with degree not more than 2 can only consist of paths or cycles.
On cycles and paths, we have two sub-possibilities: odd-length or even-length.
We can have even-length path (as currently show in the background), but it also doesn't help with this proof (as it implies|M| = |M'|, i.e.,M'is not larger thanM).
We can have even-length cycle (as currently shown in the background) but it doesn't help with this proof (as it implies|M| = |M'|, i.e.,M'is not larger thanM).
We won't have odd-length cycle as the edges inG'only comes fromMandM'(draw a triangle which is the smallest odd length cycle and convince yourself that after assigning one edge toMand another edge toM', we cannot assign the third edge of the triangle into eitherMorM'— same situation for any other longer odd-length cycles).
Lastly, we can have odd-length path where the path starts and ends with edges from the 'larger'M'and edges inMare slightly inside, that fmf...fmf pattern. Now what is this? This is an augmenting path w.r.t.M. We earlier claimed that is no augmenting path inGw.r.tM, so again we arrive at a contradiction.
Overall conclusion: Berge's theorem is correct and it is an integral part of Augmenting Path (Plus) algorithm and also later on: Kuhn-Munkres (Hungarian) and Edmonds' Matching algorithms.
Recall: Berge's theorem states:A matchingMin graphGis maximum iff there is no more augmenting path in G.
TheAugmenting Path Algorithm(on Bipartite Graph) is a simple O(V*(V+E)) = O(V2+ VE) = O(VE) implementation (a modification of DFS) of that theorem: Find and then eliminate augmenting paths in Bipartite GraphG.
ClickAugmenting Path Algorithm Demoto visualize this algorithm on a special test case called X̄ (X-bar).
Basically, this Augmenting Path Algorithm scans through all vertices on the left set (that were initially free vertices) one by one. SupposeLon the left set is a free vertex, this algorithm will recursively (via modification of DFS) go to a vertexRon the right set:
IfRis another free vertex, we have found one augmenting path (e.g., Augmenting Path 0-2 initially), and
IfRis already matched (this information is stored atmatch[R]), we immediately return to the left set and recurse (e.g, path 1-2-immediately return to 0-then 0-3, to find the second Augmenting Path 1-2-0-3)
vi match, vis;           // global variablesint Aug(int L) {         // notice similarities with DFS algorithmif (vis[L]) return 0;  // L visited, return 0vis[L] = 1;for (auto& R : AL[L])if ((match[R] == -1) || Aug(match[R])) { // the key modificationmatch[R] = L;      // flip statusreturn 1;          // found 1 matching}return 0;              // Augmenting Path is not found}
// in int main(), build the bipartite graph// use directed edges from left set (of size VLeft) to right setint MCBM = 0;match.assign(V, -1);for (int L = 0; L < VLeft; ++L) { // try all left verticesvis.assign(VLeft, 0);MCBM += Aug(L);      // find augmenting path starting from L}printf("Found %d matchings\n", MCBM);
Please see the full implementation at Competitive Programming book repository:mcbm.cpp|py|java|ml.
If we are given aCompleteBipartite GraphKN/2,N/2, i.e.,V = N/2+N/2 = NandE = N/2×N/2 = N2/4 ≈ N2, thenthe Augmenting Path Algorithm discussed earlier will run in O(VE) = O(N×N2) = O(N3).
This is only OK forV∈ [400..500] in a typical 1s allowed runtime in many programming competitions.
Try executing thestandardAugmenting Path Algorithm on thisExtreme Test Case, which is an almost completeK5,5Bipartite Graph.
It feels bad, especially on the latter iterations...So, should we avoid using this simple Augmenting Path algorithm?
The key idea of Hopcroft-Karp (HK) Algorithm (invented in 1973) is identical toDinic's Max Flow Algorithm, i.e., prioritize shortest augmenting paths (in terms of number of edges used) first. That's it, augmenting paths with 1 edge are processed first before longer augmenting paths with 3 edges, 5 edges, 7 edges, etc (the length always increase by 2 due to the nature of augmenting path in a Bipartite Graph).
Hopcroft-Karp Algorithm has time complexity of O(√(V)E) —analysis omitted for now. This allows us to solve MCBM problem withV∈ [1000..1500] in a typical 1s allowed runtime in many programming competitions — the similar range as with running Dinic's algorithm on Bipartite Matching flow graph.
Try HK Algorithm on the sameExtreme Test Caseearlier. You will notice that HK Algorithm can find the MCBM in a much faster time than the previous standard O(VE) Augmenting Path Algorithm.
Since Hopcroft-Karp algorithm is essentially also Dinic's algorithm, we treat both as 'approximately equal'.
However, we can actually make the easy-to-codeAugmenting Path Algorithmdiscussed earlierto avoid its worst case O(VE) behavior by doing O(V+E) randomized (to avoid adversary test case) greedy pre-processingbeforerunning the actual algorithm.
This O(V+E) additional pre-processing step is simple: For every vertex on the left set, match it with arandomly chosenunmatched neighbouring vertex on the right set. This way, we eliminate many trivial (one-edge) Augmenting Paths that consist of a free vertexu, an unmatched edge(u, v), and a free vertexv.
Try Augmenting Path Algorithm Plus on the sameExtreme Test Caseearlier. Notice that the pre-processing step already eliminates many trivial 1-edge augmenting paths, making the actual Augmenting Path Algorithm only need to do little amount of additional work.
Quite often, onrandomly generatedBipartite Graph, the randomized greedy pre-processing step has cleared most of the matchings.
However, we can construct test case like:Example Graphs, Corner Case, Rand Greedy AP Killerto make randomization as ineffective as possible. For every group of 4 vertices, there are 2 matchings. Random greedy processing has 50% chance of making mistake per group (but since each group has only short Augmenting Paths, the fixes are not 'long'). Try thisTest Case with Multiple Componentscase to see for yourself.
The worst case time complexity is no longer O(VE) but now O(kE) wherekis a small integer, much smaller thanV,kcan be as small as 0 and is at mostV/2(any maximal matching, as with this case, has size of at least half of the maximum matching). In ourempirical experiments, we estimatekto be "about √(V)" too. This version of Augmenting Path Algorithm Plus also allows us to solve MCBM problem withV∈ [1000..1500] in a typical 1s allowed runtime in many programming competitions.
So, when presented with an MCBM problem, which route should we take?
Reduce the MCBM problem into Max-Flow and use Dinic's algorithm (essentially Hopcroft-Karp algorithm) and getsO(√(V)E)performance guarantee but with a much longer implementation?
Use Augmenting Path algorithm with Randomized Greedy Processing withO(kE)performance with good empirical results and a much shorter implementation?
Discussion: Discuss these two routes!
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
NEW FOR 2025. We have just added Min-Cost-Max-Flow (mcmf) in maxflow visualization and Hungarian/Kuhn-Munkres visualization in this VisuAlgo page.
However, these features are still experimental.
Do report to Prof Halim if you encounter technical issue(s).
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
When Graph Matching is posed on general graphs (the MCM problem), it is (much) harder to find Augmenting Path. In fact, before Jack Edmonds published his famous paper titled "Paths, Trees, and Flowers" in 1965, this MCM problem was thought to be an (NP-)hard optimization problem.
There are two Max Cardinality Matching (MCM) algorithms in this visualization:
O(V^3)Edmonds' Matchingalgorithm (without greedy pre-processing),
O(V^3)Edmonds' Matchingalgorithm (with greedy pre-processing),
In General Graph (like the graph shown in the background that has |MCM| = 4), we may have Odd-Length cycle. Augmenting Path is not well defined in such a graph, hence we cannot easily implementClaude Berge's theoremlike what we did with Bipartite Graph.
Jack Edmonds call a path that starts from a free vertexu, alternates between free, matched, ..., free edges, and returns to thesamefree vertexuas aBlossom. This situation is only possible if we have Odd-Length cycle, i.e., in a non-Bipartite Graph. For example, assume edge 1-2 has been matched in the graph shown in the background, then path 3-1=2-3 is a blossom.
Edmonds then proposedBlossom shrinking/contraction and expansion algorithmto solve this issue. For details on how this algorithm works, read CP4 Section 9.28 as the current visualization of Edmonds' matching algorithm in VisuAlgo is still 'a bit too hard too understand' for beginners, tryEdmonds' Matching. In a live class in NUS, these steps will be explained verbally.
This algorithm can be implemented in O(V^3).
As with theAugmenting Path Algorithm Plusfor the MCBM problem, we can also do randomized greedy pre-processing step to eliminate as many 'trivial matchings' as possible upfront. This reduces the amount of work ofEdmonds' Matching Algorithm, thus resulting in a faster time complexity — analysis TBA.
We have not added the visualization(s) for weighted variant ofMCMproblem. They are for future work.
TheHungarian(Kuhn-Munkres) algorithm visualization forweighted MCBMis very new and requires users testing, thus do report if you encounter technical issue(s).
To strengthen your understanding about these Graph Matching problem, its variations, and the multiple possible solutions, please try solving as many of these programming competition problems listed below:
Standard MCBM (but need a fast algorithm):Kattis - flippingcards
Greedy Bipartite Matching:Kattis - froshweek2(you donotneed a specific MCBM algorithm for this,in fact, it will be too slow if you use any algorithm discussed here)
Special case of an NP-hard optimization problem:Kattis - bilateral
Rather straightforward weighted MCBM:Kattis - engaging
To tackle those programming contest problems, you are allowed to use/modify our implementation code for Augmenting Path Algorithm (with Randomized Greedy Preprocessing):mcbm.cpp|py|java|ml
You have reached the last slide. Return to 'Exploration Mode' to start exploring!
Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.
Edit Graph
Input Graph
Modeling
Example Graphs
Augmenting Path
Rook Attack
Go
Generate Random Bipartite Graph, specify n, m, and edge density
Go
Generate Random Weighted Bipartite Graph, specify n
Go
K2,2
X̄
F-mod
Corner Case
House of Cards
Rand Greedy AP Killer (many X̄)
Undirected MF Killer
Special Case
Grid
Tree
Even Cycle
Odd Line
Even Line
Performance Test
K7,7 (d=50%)
K7,7 (SMT 3)
K5,5 (d=50%)
K5,5 (SMT 3)
Matching with Capacity
waif (WA)
CP4 3.11a*
Theorem
SMT 4
SMT 3
SMT 2
SMT 1
HMT 2
HMT 1
Sample Weighted Bipartite
Sample Weighted Bipartite TUM
Sample Weighted CP4 9.24 UVa 10746
Standard
With Randomized Greedy Preprocessing
Hopcroft Karp
Edmonds Blossom
Edmonds Blossom + Greedy
Hungarian
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
AVertex Cover(VC) of a connected undirected (un)weighted graphGis asubset of vertices VofGsuch thatfor every edgeinG,at least one of its endpoints is in V. AMinimum Vertex Cover (MVC)(Minimum Weight Vertex Cover (MWVC)for the weighted variant) ofGis a VC that has the smallest cardinality (if unweighted) or total weight (if weighted) among all possible VCs. A graph can have multiple VCs but the cardinality/total weight of its MVC/MWVC is unique.
There is another problem calledMaximum Independent Set(MIS) that attempts to find thelargestsubset of vertices in a (un)weighted graphGwithout any adjacent vertices in the subset. Interestingly, thecomplement of an MVC of a graph is an MIS.
At the end of every visualization, when an algorithm highlights an MVC solution of the currently displayed graph inorange color. For non-approximation solutions, the visualization will also highlight the MIS solution (which is V \ MVC) withlight blue color.
MVC, MWVC, MIS, (and MWIS) are all NP-hard combinatorial optimization problems.
Remarks: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.If you are an NUS student and a repeat visitor, pleaselogin.
There are two available modes: Unweighted (default) and Weighted. You can switch between the two modes by clicking the respective tab.
There are algorithms that work in both modes and there are algorithms that only work in a certain mode.
Pro-tip 1: Since you are notlogged-in, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode:[PageDown]/[PageUp]to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use[→ or ↓/← or ↑]to do the same),and[Esc]to toggle between this e-Lecture mode and exploration mode.
View the visualisation of the selected MVC algorithms here.
Originally, all vertices and edges in the input graph are colored with the standard black outline. As the visualization goes on, the colorlight bluewill be used to denote covered edges and the colororangeon edge will be used to show traversed edges.
At the end of the selected MVC algorithm, if it finds aminimumVC, it will highlight the MVC vertices withorangecolor and the non MVC vertices (a.k.a. the MIS vertices) withlight bluecolor. Otherwise, if the found vertex cover is not proven to be the minimal one (e.g., the algorithm used is an approximation algorithm), it will highlight the vertices that belong to the found vertex cover withorangecolor without highlighting the MIS vertices.
Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolutionor larger(typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (F11) to enjoy this setup. However, you can use zoom-in (Ctrl +) or zoom-out (Ctrl -) to calibrate this.
There are two different ways to specify an input graph:
Edit Graph: You can edit the currently displayed undirected (weighted for MWVC mode) graph into any other undirected (weighted for MWVC mode) graph.
Example Graphs: You can select from the list of example undirected (weighted for MWVC mode) graphs to get you started.
Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode):Spacebarto play/pause/replay the animation,←/→to step the animation backwards/forwards, respectively, and-/+to decrease/increase the animation speed, respectively.
Bruteforce: It tries all possible 2^Vsubsets of vertices. In every iteration, it checks whether the currently selected subset of vertices is a valid vertex cover by iterating over allEedges in O(E) and checking whether all edges are covered by the vertices in the currently selected subset. This bruteforce algorithm keeps the smallest size of the valid vertex cover as the answer.
This bruteforce algorithm is available in both weighted and unweighted version.
Its time complexity is O(2^V×E), i.e., extremely slow. We are in the process to improve the visualization so that the 'boring' non-improving parts are cut-out and only the important 'candidate VC' subsets are highlighted.
Discussion: But there is an alternative O(2^k×E) parameterized solution if we are told thatkis 'not-that-large'.
Unfortunately this part has not been digitized/visualized yet and is in the pipeline.
Please see CS4234 lecture note for the details.
DP on Tree: If the graph is atree, the MVC problem can be formulated as a Dynamic Programming problem where the states are (position, take_current_vertex).
Then, it can be seen that:DP(u, take) = cost[u] + sum(min(DP(v, take), DP(v, not_take))) ∀child v of u, andDP(u, not take) = sum(DP(v, take)) ∀child v of u
This DP algorithm is available in both weighted and unweighted version.
Its time complexity is O(V), i.e., very fast, but only if the input graph is a tree.
Greedy MVC on Tree: Again, if the graph is anunweightedtree, it can be solved greedily by observing that if there is any MVC solution that takes a leaf vertex, we can obtain a "not worse" solution by taking the parent of that leaf vertex instead. After removing all covered vertices, we can apply the same observation and repeat it until every vertex is covered.
This greedy MVC algorithm is only available in unweighted mode.
Its time complexity is O(V), i.e., very fast, but only if the input graph is an unweighted tree.
Kőnig's Theorem: From Kőnig's Theorem, the size of MVC in anunweighted bipartitegraph is equal to the cardinality of the maximum matching of the bipartite graph. In the case ofweighted bipartitegraph, we can see that this theorem also holds true, with a tweak in how we construct the graph. In this visualization, we use a reduction to max flow problem to get the value of the MVC.
This algorithm is available in both weighted and unweighted version.
Its time complexity is O(V×E) (for unweighted version; can be smaller with pre-processing) or O(E^2 ×V)/O(V^2 ×E) (for weighted version, depending on the max flow algorithm used).
There are several known approximation algorithms for MVC:
For unweighted version, we have either the deterministic 2-approximation or probabilistic 2-approximation (in expectation),
For weighted version we have the Bar-Yehuda and Even's 2-approximation algorithm.
Note that these algorithms only yield an "approximated" MVC, meaning that they are not a trueminimumvertex cover, but a good enough one.
Unfortunately this part has not been digitized yet and is in the pipeline.
Please see CS4234 lecture note for the details.
You have reached the last slide. Return to 'Exploration Mode' to start exploring!
Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.
Edit Graph
Input Graph
Example Graphs
Bruteforce
MVC on Tree
MVC on Bipartite Graph
Approximation
Parameterized MVC
General Graph
Medium Graph
CS4234 Sample
Flow Graph
House of Cards
CP4 4.7
CP4 4.3
CP4 4.2
CP4 4.1
Corner Case
Unconnected Graph
Weighted Det 2-approx Killer
Star (Tree) - Center
Star (Tree) - Leaves
Unweighted Det 2-approx Killer (K Edges)
Special Case
Pseudoforest
Bipartite Graph
Bipartite (Tree)
Tree (Large)
Tree (Small)
Line (odd)
Line (even)
Max Clique
Dense Graph Bar
K̅5
K̅4
Dense Graph
K5
K4
DP on Tree
Greedy MVC on Tree
Kőnig's Theorem
Deterministic 2-opt
Probabilistic 2-opt
Parameterized MVC
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
Given an undirected weighted graphG = (V, E)and an integersthat partitions the set of verticesV = [0, 1, ..., |V|-1]into a set ofrequiredverticesR = [0, 1, ..., s-1]and a set ofSteinerverticesS = [s, s+1, ..., |V|-1], the General Steiner Tree problem is a problem of finding a subsetS' ⊆ Sof theSteinervertices and a spanning treeT = (R ⋃ S', E)of minimum weight. The weight of the treeTis simply the sum of its edge weights.
This General Steiner Tree problem is a generalization of the more well-knownMinimum Spanning Tree problem (MST).
Unlike MST, which has a polynomial solution (e.g., O(E log V) Kruskal's/Prim's algorithm), this general Steiner-Tree problem is an NP-hard combinatorial optimization problem.
Remarks: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.If you are an NUS student and a repeat visitor, pleaselogin.
There are a few other variants of this general Steiner-Tree problem, e.g., the Euclidean-Steiner-Tree and the Metric-Steiner-Tree problems.
In the Euclidean-Steiner-Tree problem, there areVdistinct points (setR) on an Euclidean (2-dimensional) plane, the job is to find a(n additional, possibly empty) set ofSteinerpointsS(can be anywhere in the 2-D plane) and a spanning treeT = (R ⋃ S, E)such that the weight ofTis minimized. The weight of any two points is simply the Euclidean distance of those two points.
In the Metric-Steiner-Tree problem, it is like the Euclidean-Steiner-Tree, but this time the additional Steiner points are given as a set ofSupfront. The weight of any two points must satisfymetric spaceproperties.
Euclidean-Steiner Tree, Metric-Steiner-Tree, and the general Steiner-Tree that is visualized in this website, are all NP-hard optimization problems.
Pro-tip 1: Since you are notlogged-in, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode:[PageDown]/[PageUp]to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use[→ or ↓/← or ↑]to do the same),and[Esc]to toggle between this e-Lecture mode and exploration mode.
View the visualisation of the selected Steiner-Tree algorithms here.
Originally, all vertices and edges in the input graph are colored with the standard black outline. As the visualization goes on, the colorlight bluewill be used to denote the set of required verticesRand the colororangewill be used to show Steiner vertices that are currently used.
At the end of the selected Steiner-Tree algorithm, we show the best spanning tree = the Steiner treeT.
Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolutionor larger(typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (F11) to enjoy this setup. However, you can use zoom-in (Ctrl +) or zoom-out (Ctrl -) to calibrate this.
There are two different ways to specify an input graph:
Edit Graph: You can edit the currently displayed undirected weighted graph into any other undirected weighted graph.
Example Graphs: You can select from the list of example undirected weighted graphs to get you started.
One day, we will provide an easy way to relabel vertices in any currently loaded graph so that the set of required verticesRis always numbered with[0, 1, ..., s-1](thus the rest are the potential Steiner verticesS).
Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode):Spacebarto play/pause/replay the animation,←/→to step the animation backwards/forwards, respectively, and-/+to decrease/increase the animation speed, respectively.
There are 3 special cases of the general Steiner-Tree problem with polynomial solutions:
s = 2, that implies that the only required verticesR = [0, 1], we can simply run O((V+E) log V)Dijkstra's algorithmto find theShortest Path Spanning Treethat connects source vertex 0 with destination vertex 1 (or vice versa). This spanning tree will also be the required Steiner Tree.
s = |V|, that implies that all of the|V|vertices, i.e.,R = [0, 1, ..., |V|-1]are all required, we can simply run O(E log V)Kruskal's or Prim's algorithmto find the fullMinimum Spanning Tree (MST)of the entire graph. This MST will also be the required Steiner Tree.
IfGis a tree: Details TBA.
But whens = [3, 4, ..., |V|-2], we have no choice but to run exponential algorithms as these cases fall into general cases of the NP-hard general Steiner-Tree problem.
One possible way is to try all possible subsets of the|V|-svertices that can be part of the optimal Steiner Tree. Each time, we combine vertices inR = [0, 1, ..., s-1]with the currently chosen subset of potential Steiner vertices, run an O(E) Kruskal's algorithm (without re-sorting the edge list by weight anymore) for each of the2|V|-spossible subsets, and report the best Steiner Tree. This is an exponential algorithm and this visualization page shows this algorithm.
There is a more optimized exponential algorithm called the Dreyfus-Wagner Dynamic Programming (DP) algorithm that avoids recomputation of sub-problems.
Unfortunately this part has not been digitized/visualized yet and is in the pipeline.
Please see CS4234 lecture note for the details.
You have reached the last slide. Return to 'Exploration Mode' to start exploring!
Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.
Edit Graph
Example Graphs
Exact
Approximation
K4
K5
K5 Best
W5
CS4234 Example 1
CS4234 Example 2
Small Graph
Go
Go
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
Linked List is a data structure consisting of a group of vertices (nodes) which together represent a sequence. Under the simplest form, each vertex is composed of a data and a reference (link) to the next vertex in the sequence. Try clickingSearch(77)for a sample animation on searching a value in a (Singly) Linked List.
Linked List (and its variations) can be used as the underlying data structure to implement List, Stack, Queue, and Deque ADTs (read thisWikipedia article about ADTif you are not familiar with that term). Another potential data structure that can be used to implement List ADT is (resize-able)array.
In this visualization, we discuss (Singly) Linked List (LL) — with a single next pointer — and its two variants: Stack and Queue, and also Doubly Linked List (DLL) — with both next and previous pointers — and its variant: Deque.
Remarks: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.If you are an NUS student and a repeat visitor, pleaselogin.
We decide to group five related modes involving Linked List (LL, Stack, Queue, DLL, Deque) in one single visualization page. To facilitate more diversity, we randomize the selected mode upon loading this direct URL: https://visualgo.net/en/list.
However, you can use the following URL shortcuts to access individual mode directly (only works for logged-in users who have cleared reading all 3 sectors of these lecture notes):
https://visualgo.net/en/ll,
https://visualgo.net/en/stack,
https://visualgo.net/en/queue,
https://visualgo.net/en/dll,
https://visualgo.net/en/deque.
Pro-tip 1: Since you are notlogged-in, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode:[PageDown]/[PageUp]to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use[→ or ↓/← or ↑]to do the same),and[Esc]to toggle between this e-Lecture mode and exploration mode.
Linked List data structure is commonly taught in Computer Science (CS) undergraduate courses for a few reasons:
It is a simple linear data structure,
It has a range of potential applications as a list ADT e.g., student list, event list, appointment list, etc (albeit there are other more advanced data structures that can do the same (and more) applications better) or as stack/queue/deque ADTs,
It has interesting corner/special cases to illustrate the need for a good implementation of a data structure,
It has various customization options and thus usually this Linked List data structure is taught using Object-Oriented Programming (OOP) way.
Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolutionor larger(typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (F11) to enjoy this setup. However, you can use zoom-in (Ctrl +) or zoom-out (Ctrl -) to calibrate this.
List is a sequence of items/data where positional order matter {a0, a1, ..., aN-2, aN-1}.Common List ADT operations are:
get(i)— maybe a trivial operation, returnai(0-based indexing),
search(v)— decide if item/datavexists (and report its position/index)or not exist (and usually report a non existing index -1) in the list,
insert(i, v)— insert item/datavspecifically at position/indexiin the list, potentially shifting the items from previous positions: [i..N-1] by one position to their right to make a space,
remove(i)— remove item that is specifically at position/indexiin the list, potentially shifting the items from previous positions: [i+1..N-1] by one position to their left to close the gap.
Discussion 1: What if we want to remove item with specific valuevin the list?
Discussion 2: Can a List ADT contains duplicate items, i.e., ai= ajwhere i ≠ j?
Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode):Spacebarto play/pause/replay the animation,←/→to step the animation backwards/forwards, respectively, and-/+to decrease/increase the animation speed, respectively.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Please review(Compact) Arraydata structure that can also be used to implement List ADT.
For fixed-size collections with known max limit of number of items that will ever be needed, i.e., the max size ofM, then array is already a reasonably good data structure for List ADT implementation.
For variable-size collections with unknown sizeMand where dynamic operations such as insert/remove are common, a simple (fixed-size) array is actually a poor choice of data structure.
For such applications, there are better data structures, including Linked List. Read on...
We now introduce the Linked List data structure. It uses pointers/references to allow items/data to benon-contiguousin memory (that is the main difference with asimple array). The items are ordered from index 0 to indexN-1 by associating itemiwith its neighbour itemi+1through a pointer.
In its basic form, a single vertex (node) in the Linked List has this rough structure:
struct Vertex { // we can use either C struct or C++/Python/Java classint item; // the data is stored here, an integer in this exampleVertex* next; // this pointer tells us where is the next vertex};
Using the default example Linked List [22 (head)->2->77->6->43->76->89 (tail)] for illustration, we have:a0with itsitem= 22 and itsnext=a1,a1with itsitem= 2 and itsnext=a2,...a6with itsitem= 89 and itsnext=null.
Discussion: Which one is better for a C++ implementation of Linked List? struct or class? How about Python or Java implementation?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
We also have a few additional data that we remember in this Linked List data structure. We use the default example Linked List [22 (head)->2->77->6->43->76->89 (tail)] for illustration.
Theheadpointer points toa0— it is 22, nothing points to the head item,
The current number of elementsNin the Linked List —N = 7elements.
Thetailpointer points toaN-1— it isa6= 89, nothing is after the tail item.
That's it, we only add three more extra variables in data structure.
Note that there are various subtle differences found in many Computer Science textbooks on how to implement a (Singly) Linked List e.g., use tail pointer or not, circular or not, use dummy head item or not, allow duplicate items or not — seethis slide.
Our version in this visualization (with tail pointer, not circular, without dummy head, disallow duplicate) may not be 100% the same compared to what you learn in your class but the basic ideas should remain the same.
In this visualization, each vertex has Integer item, but this can easily be changed to any other data type as needed.
Since we only keep the head and tail pointers, list traversal subroutine is needed to reach positions other than the head (index 0) and the tail (indexN-1).
As this sub-routine is so frequently used, we will abstract it out as a function. The code below is written in C++.
Vertex* Get(int i) { // returns the vertexVertex* ptr = head; // we have to start from headfor (int k = 0; k < i; ++k) // advance forward i time(s)ptr = ptr->next; // the pointers are pointing to the higher indexreturn ptr;}
It runs in O(N) asican be as big as indexN-2.Compare this witharraywhere we can access indexiin O(1) time.
As we only have direct reference to the first head item and the last tail item, plus the pointers are pointing to theright(higher position/index), we can only access the rest by starting from the head item and hopping through the next pointers. On the default [22 (head)->2->77->6->43->76->89 (tail)], we have:
Search(77)— found in the example above at position/index 2 (0-based indexing).
Search(7)— not found in the example above, and this is only known after allNitems are examined, soSearch(v)has O(N) worst case time complexity.
There are more cases thanarrayversion due to the nature of Linked List.
Most CS students who learn Linked List for the first time usually are not aware of all cases until they figure it out themselves when their Linked List code fail.
In this e-Lecture, we directly elaborate all cases.
Forinsert(i, v), there are four (legal) possibilities, i.e., itemvis added to:
The head (before the current first item) of the linked list,i = 0,
An empty linked list (which fortunately similar to the previous case),
The position beyond the last (the current tail) item of the linked list,i = N,
The other positions of the linked list,i = [1..N-1].
The (C++) code for insertion at head is simple and efficient, in O(1):
Vertex* vtx = new Vertex(); // create new vertex vtx from item vvtx->item = v;vtx->next = head; // link this new vertex to the (old) head vertexhead = vtx; // the new vertex becomes the new head
TryInsertHead(50), which isinsert(0, 50), on the example Linked List [22 (head)->2->77->6->43->76->89 (tail)].
Discussion: What happen if we usearrayimplementation for insertion at head of the list?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Empty data structure is a common corner/special case that can often cause unexpected crash if not properly tested. It is legal to insert a new item into a currently empty list, i.e., at indexi = 0. Fortunately, the same pseudo-code for insertion at head also works for an empty list so we can just use the same code as inthis slide(with one minor change, we also need to set tail = head).
TryInsertHead(50), which isinsert(0, 50), but on the empty Linked List [].
With the Linked List traversalGet(i)sub-routine, we can now implement insertion in the middle of the Linked List as follows (in C++):
Vertex* pre = Get(i-1); // traverse to (i-1)-th vertex, O(N)aft = pre->next; // aft cannot be null, think about itVertex* vtx = new Vertex(); // create new vertexvtx->item = v;vtx->next = aft; // link thispre->next = vtx; // and this
TryInsert(3, 44)on the example Linked List  [22 (head)->2->77->6->43->76->89 (tail)].
Also tryInsert(6, 55)on the same example Linked List. This is a corner case: Insert at the position of tail item, shifting the tail to one position to its right.
This operation is slow, O(N), due to the need for traversing the list (e.g. ificlose toN-1).
If we also remember the tail pointer as with the implementationin this e-Lecture(which is advisable as it is just one additional pointer variable), we can perform insertion beyond the tail item (ati = N) efficiently, in O(1):
Vertex* vtx = new Vertex(); // this is also a C++ codevtx->item = v; // create new vertex vtx from item vtail->next = vtx; // just link this, as tail is the i = (N-1)-th itemtail = vtx; // now update the tail pointer
TryInsertTail(10), which isinsert(7, 10), on the example Linked List [22 (head)->2->77->6->43->76->89 (tail)] . A common misconception is to say that this is insertion at tail. Insertion at tail element isinsert(N-1, v). Insertionbeyondthe tail isinsert(N, v).
Discussion: What happen if we usearrayimplementation for insertion beyond the tail of the list?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Forremove(i), there are three (legal) possibilities, i.e., indexiis:
The head (the current first item) of the linked list,i = 0, it affects the head pointer
The tail of the linked list,i = N-1, it affects the tail pointer
The other positions of the linked list,i = [1..N-2].
Discussion: Compare this slide withInsertion Cases slideto realize the subtle differences. Is removing anything from an already empty Linked List considered 'legal'?
This case is straightforward (written in C++):
if (head == NULL) return; // avoid crashing when SLL is emptyVertex* tmp = head; // so we can delete it laterhead = head->next; // book keeping, update the head pointerdelete tmp; // which is the old head
TryRemoveHead()repeatedly on the (shorter) example Linked List [22 (head)->2->77->6 (tail)]. It will continuously working correctly up until the Linked List contains one item where the head = the tail item. We prevent execution if the LL is already empty as it is an illegal case.
Discussion: What happen if we usearrayimplementation for removal of head of the list?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
With the Linked List traversalGet(i)sub-routine (discussed earlier), we can now implement removal of the middle item of the Linked List as follows (in C++):
Vertex* pre = Get(i-1); // traverse to (i-1)-th vertex, O(N)Vertex* del = pre->next, aft = del->next;pre->next = aft; // bypass deldelete del;
TryRemove(5), the element at indexN-2(asN = 7in the example [22 (head)->2->77->6->43->76->89 (tail)] .This is the worst O(N) case on the example above.
Note thatRemove(N-1)is removal at tail that requires us to update the tail pointer, see the next case.
We can implement the removal of the tail of the Linked List as follows, assuming that the Linked List has more than 1 item (in C++):
Vertex* pre = head;tmp = head->next;while (tmp->next != null) // while my neighbor is not the tailpre = pre->next, tmp = tmp->next;pre->next = null;delete tmp; // tmp = (old) tailtail = pre; // update tail pointer
TryRemoveTail()repeatedly on the (shorter) example Linked List [22 (head)->2->77->6 (tail)]. It will continuously working correctly up until the Linked List contains one item where the head = the tail item and we switch toremoval at headcase. We prevent execution if the LL is already empty as it is an illegal case.
Actually, if we also maintain the size of the Linked ListN(compare withthis slide), we can use the Linked List traversal sub-routineGet(i)to implement the removal of the tail of the Linked List this way (in C++):
Vertex* pre = Get(N-2); // go to one index just before tail, O(N)pre->next = null;delete tail;tail = pre; // we have access to old tail
Notice that this operation is slow, O(N), just because of the need to update the tail pointer from itemN-1 backwards by one unit to itemN-2 so that future insertion after tail remains correct... This deficiency will belater addressedin Doubly Linked List variant.
Discussion: What happen if we usearrayimplementation for removal of tail of the list?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
get(i)is slow: O(N).In Linked List, we need to perform sequential access from head element.
search(v)In the best case,vis found at the first position, O(1).In the worst case,vis not found in the list and we require O(N) scan to determine that.
insert(i, v)In the best case, insert ati = 0or ati = N, head and tail pointers help, O(1).In the worst case, insert ati = N-1, we need to find the itemN-2just before the tail, O(N).
remove(i)In the best case, remove ati = 0, head pointer helps, O(1).In the worst case, remove ati = N-1, due to the need to update the tail pointer, O(N).
Pure (Singly) Linked List applications are surprisingly rare as the simpler resizeable compact array (vector) can do the job better, compare theLinked List versionwith thecompact array version.
However, the basic concept of Linked List that allows the vertices to be non-contiguous in memory makes it an excellent resize-able data structure for the next two other Abstract Data Types:StackandQueue.
Stack is a particular kind of Abstract Data Type in which the main operations on the collection are the addition of an item to the collection, known as push, only to the top of the stack and removal of an item, known as pop, only from the top of the stack.
It is known as Last-In-First-Out (LIFO) data structure, e.g., the stack of book below.
In most implementations and also in this visualization, Stack is basically aprotected(Singly) Linked List where we can only peek at the head item, push a new item only to the head (insert at head), e.g., tryInsertHead(6), and pop existing item only from the head (remove from head), e.g., tryRemoveHead(). All operations are O(1).
In this visualization, we orientate the (Single) Linked List top down, with the head/tail item at the top/bottom, respectively. In the example, we have [2 (top/head)->7->5->3->1->9 (bottom/tail)]. Due to vertical screen size limit (in landscape mode), we only allow a Stack of at most 7 items in this visualization.
Discussion: Can we use vector, a resizeable array, to implement Stack ADT efficiently?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Stack has a few popular textbook applications. Some examples:
Bracket Matching,
Postfix Calculator,
A few other interesting applications that are not shown for pedagogical purposes.
Mathematical expression can get quite convoluted, e.g.,{[x+2]^(2+5)-2}*(y+5).
Bracket Matching problem is a problem of checking whether all brackets in the given input are matched correctly, i.e., ( with ), [ with ] and { with }, and so on.
Bracket Matching is equally useful for checking the legality of a source code.
Discussion: It turns out that we can use Stack's LIFO behavior to solve this problem.The question is how?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Postfix expression is a mathematical expression in:operand1 operand2 operatorformat which is different from what human is most comfortable at, the Infix expression:operand1 operator operand2.
For example, expression2 3 + 4 *is the Postfix version of(2+3)*4.
In Postfix expression, we do not need brackets.
Discussion: It turns out that we can also use Stack to solve this problem efficiently.The question is how?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Queue is another Abstract Data Type in which the items in the collection are keptin orderand the main operations on the collection are the addition of items to the back position (enqueue) and removal of items from the front position (dequeue).
It is known asFirst-In-First-Out (FIFO)data structure as the first item to be enqueued will eventually be the first item to be dequeued, as in real life queues (see below).
If we simply use thecompact arrayimplementation for this Queue ADT witha0is the front of the queue andaN-1is the back of the queue, we will encounter major performance issue with thedequeueoperation.
This is because insertion at the back of a compact array is fast, O(1), but removal at the front of a compact array is slow due to the need to shift items, please reviewthis slide.
Another possible array implementation is to avoid that shifting of items during dequeue operation by havingtwoindices:front(the index of the queue front-most item, increased after a dequeue operation) andback(the index of the queue back-most item, also increased after an enqueue operation).
Suppose we use an array of sizeM = 8items and the content of our queue is as follows:[(2,4,1,7),-,-,-,-]withfront = 0(underlined)andback = 3(italic). The current active queue elements are highlighted with(green color).
If we call dequeue(), we have[-,(4,1,7),-,-,-,-],front = 0+1 = 1, andback = 3.
If we call enqueue(5), we have[-,(4,1,7,5),-,-,-],front = 1, andback = 3+1 = 4.
However, many dequeue and enqueue operations later, we may have[-,-,-,-,-,6,2,3],front = 5, andback = 7. By now, we cannot enqueue anything else albeit we have many empty spaces at the front of the array.
If we allow bothfrontandbackindices to "wrap back" to index 0 when they have reached indexM-1, we effectively make the array "circular" and we can use the empty spaces.
For example, if we call enqueue(8) next, we have[8),-,-,-,-,(6,2,3],front = 5, andback = (7+1)%8 = 0.
Yet, this does not solve the main problem of fixed-size array implementation. A few more enqueue operations later, we may have[8,10,11,12,13),(6,2,3],front = 5, andback = 4. At this point (front = (back+1) % M)), we cannot enqueue anything else.
Do note that if we know that our queue size will never exceed the fixed array sizeM, then the circular array idea is actually already a good way to implement Queue ADT.
However, if we do not know the upper bound of queue size, we can enlarge (double) the size of the array, e.g., makeM = 2*8 = 16(two-times larger), but that will entail re-copying the items from indexfronttobackin aslow(but rare) O(N) process to have[(6,2,3,8,10,11,12,13),-,-,-,-,-,-,-,-,],front = 0, andback = 7.
PS1: If you understand amortized analysis, this heavy O(N) cost when the circular array is full can actually be spread out so that each enqueue remains O(1) in amortized sense.
PS2: There is an alternative way to implement an efficient Queue using two Stacks. How?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
If we do not really know the the upper bound of queue size, then Singly Linked List (SLL) can be a good data structure to implement Queue ADT.
Recall that in a Queue, we only need the two extreme ends of the List, one for insertion (enqueue) only and one for removal (dequeue) only.
If we reviewthis slide, we see that insertionafter tailand removalfrom headin a Singly Linked List are fast, i.e., O(1). Thus, we designate the head/tail of the Singly Linked List as the front/back of the queue, respectively. Then, as the items in a Linked List arenotstored contiguously in computer memory, our Linked List can grow and shrink as needed.
In our visualization, Queue is basically aprotectedSingly Linked List where we can only peek at the head item, enqueue a new item to one position after the current tail, e.g., tryEnqueue(random-integer), and dequeue existing item from the head, e.g., tryRemoveHead()(which is essentially a dequeue operation). All operations are O(1).
Queue ADT is usually used to simulate real queues.
One super important application of Queue ADT is inside theBreadth-First Searchgraph traversal algorithm.
Doubly Linked List (DLL) is 99% the same as its Singly Linked List version. The main difference is that now each vertex containstwopointers. Thenextpointer is the same as in Singly Linked List version in which it links itemaiwith the next itemai+1, if exists. The additionalprevpointer also links itemaiwith the previous itemai-1, if exists.
The usage ofprevpointers makes it possible to move/iteratebackwardsat the expense of two-times memory usage requirement as now each vertex records one additional pointer. The positive side effect of this ability to move backwards is now we can address the weakremoval at tail caseof the Singly Linked List.
In this visualization, notice that the edges in Doubly Linked List (and later Deque) are undirected (bidirectional) edges.
The main problem of removal of the tail element in the Singly Linked List, even if we have direct access to the tail item via the tail pointer, is that we then have to update the tail pointer to point to one item just before the tail after such removal.
With Doubly Linked List ability to movebackwards, we can find this item before the tail viatail->prev... Thus, we can implement removal of tail this way (in C++):
Vertex* tmp = tail; // remember tail itemtail = tail->prev; // the key step to achieve O(1) performance :Otail->next = null; // remove this dangling referencedelete tmp; // remove the old tail
Now this operation is O(1). TryRemoveTail()on example DLL [22 (head)<->2<->77<->6<->43<->76<->89 (tail)].
As we have one more pointerprevfor each vertex, their values need to be updated too during each insertion or removal. Try all these operations on example DLL [22 (head)<->2<->77<->6<->43<->76<->89 (tail)].
TryInsertHead(50)— additional step: 22'sprevpointer points to new head 50.
TryInsertTail(10)— additional step: 10'sprevpointer points to old tail 89.
TryInsert(3, 44)— additional step: 6's/44'sprevpointers point to 44/77, respectively.
TryRemoveHead()— set new head 2'sprevpointer to null.
TryRemove(5)— set 89'sprevpointer to 43.
Double-ended queue (often abbreviated to deque, pronounced deck) is an Abstract Data Type that generalizes a Queue, for which elements can be added to or removed only fromeitherthe front (head) or back (tail).
In our visualization, Deque is basically a protected Doubly Linked List where we can only:search the head/tail item (peek front/back),insert a new item to the head/tail (tryInsertHead(50)orInsertTail(10)), andremove an existing item from the head/tail (tryRemoveHead()orRemoveTail()).
All operations are O(1).
Deque are used a few advanced applications, like finding the shortest paths 0/1-weighted graph using modified BFS, on some sliding window techniques, etc.
Create operation is the same for all five modes.
However there are minor differences for the search/insert/remove operations among the five modes.
For Stack, you can only peek/restricted-search, push/restricted-insert, and pop/restricted-remove from the top/head.
For Queue, you can only peek/restricted-search from the front (or sometimes, the back), push/restricted-insert from the back, and pop/restricted-remove from the front.
For Deque, you can peek/restricted-search, enqueue/restricted-insert, dequeue/restricted-remove from both front/back, but not from the middle.
Single (Singly) and Doubly Linked List do not have such restrictions.
We have reached the end of this e-Lecture.
But read ahead for a few extra challenges.
The following are the more advanced insights about Linked List:
What happen if we don't store the tail pointer too?
What if we use dummy head?
What if the last tail item points back to the head item?
What need to be changed to allow duplicate items (a more general List ADT)?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
C++ STL:forward_list(a Singly Linked List)stackqueuelist(a Doubly Linked List)deque(actually not using Doubly Linked List but another technique, see cppreference)
Java API:LinkedList(already a Doubly Linked List)StackQueue(actually an interface, usually implemented using LinkedList class)Deque(actually an interface, usually implemented using LinkedList class)
Python:listfor List/Stack/Queuedeque
OCaml:ListStackQueueNo built-in support for Deque
For a few more interesting questions about this data structure, please practice onLinked Listtraining module.
We also have a few programming problems that somewhat requires the usage of this Linked List, Stack, Queue, or Deque data structure:UVa 11988 - Broken Keyboard (a.k.a. Beiju Text),Kattis - backspace, andKattis - integerlists.
Try them to consolidate and improve your understanding about this data structure. You are allowed to use C++ STL, Python standard library, or Java API if that simplifies your implementation.
You have reached the last slide. Return to 'Exploration Mode' to start exploring!
Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.
Create(A)
Search
Insert
Remove
Empty
User Defined List
Go
Random
Random Sorted
Front
Back
Go
Go
Go
Front
Back
i = 0 (Head), specify v =
Go
i = N (After Tail), specify v =
Go
specify both i in [1..N-1] and v =
Go
Front
Back
1x (Dequeue)
Kx (Dequeue)
Remove i = 0 (Head)
Remove i = N-1 (Tail)
specify i in [1..N-2]
Go
1x (Pop)
Kx (Pop)
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.

Profile
Training
Tests
Log Out
A Binary (Max) Heap is acomplete binary treethat maintains theMax Heap property.
Binary Heap is one possible data structure to model an efficientPriority Queue(PQ) Abstract Data Type (ADT). In a PQ, each element has a "priority" and an element with higher priority is served before an element with lower priority (ties are either simply resolved arbitrarily or broken with standard First-In First-Out (FIFO) rule as with a normal Queue). Try clickingExtractMax()for a sample animation on extracting the max value of random Binary Heap above.
To focus the discussion scope, this visualization show a BinaryMaxHeap of integers where duplicates are allowed. Seethisfor an easy conversion to BinaryMinHeap. Generally, any other objects that can be compared can be stored in a Binary Max Heap, e.g., Binary Max Heap of floating points, etc.
Remarks: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.If you are an NUS student and a repeat visitor, pleaselogin.
Complete Binary Tree: Every level in the binary tree, except possibly the last/lowest level, is completely filled, and all vertices in the last level are as far left as possible.
Binary Max Heap property: The parent of each vertex - except the root - contains value greater than (or equal to — we now allow duplicates) the value of that vertex. This is an easier-to-verify definition than the following alternative definition: The value of a vertex - except the leaf/leaves - must be greater than (or equal to) the value of its one (or two) child(ren).
Pro-tip 1: Since you are notlogged-in, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode:[PageDown]/[PageUp]to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use[→ or ↓/← or ↑]to do the same),and[Esc]to toggle between this e-Lecture mode and exploration mode.
Priority Queue (PQ) Abstract Data Type (ADT) is similar to normal Queue ADT, but with these two major operations:
Enqueue(x): Put a new element (key)xinto the PQ (in some order),
y= Dequeue(): Return an existing elementythat has the highest priority (key) in the PQ and if ties, return any.
Discussion: Some PQ ADT reverts to First-In First-Out (FIFO) behavior of a normalQueuein the event there is a tie of highest priority (key) in the PQ. Does guaranteeing stability on equal highest priority (key) makes PQ ADT harder to implement?
Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolutionor larger(typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (F11) to enjoy this setup. However, you can use zoom-in (Ctrl +) or zoom-out (Ctrl -) to calibrate this.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode):Spacebarto play/pause/replay the animation,←/→to step the animation backwards/forwards, respectively, and-/+to decrease/increase the animation speed, respectively.
Imagine: You are anAir Traffic Controller (ATC)working in the control towerTof an airport. You have scheduled aircraftX/Yto land in the next 3/6 minutes, respectively. Both have enough fuel for at least the next 15 minutes and both are just 2 minutes away from your airport. You observe that your airport runway is clear at the moment.
In case you do not know, aircraft can be instructed to fly inholding patternnear the airport until the designated landing time.
You have to attend the live lecture to figure out what happens next...
There will be two options presented to you and you will have to decide:
Raise AND wave your hand if you choose option A,
Raise your hand but do NOT wave it if you choose option B,
If none of the two options is reasonable for you, simply do nothing.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
There are several potential usages of PQ ADT in real-life on top of what you have seen just now regarding ATC (only in live lecture).
Discussion: Can you mention a few other real-life situations where a PQ is needed?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
We are able to implement this PQ ADT using (circular)ArrayorLinked Listbut we will have slow (i.e., in O(N)) Enqueue or Dequeue operation.
Discussion: Why?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Now, let's view the visualisation of a (random) Binary (Max) Heap above. You should see a complete binary tree and all vertices except the root satisfy the Max Heap property (A[parent(i)] ≥ A[i]). Duplicate integer keys may appear (note that thestabilityof equal keys is not guaranteed).
You canToggle the Visualization Modebetween the visually more intuitive complete binary tree form or the compact array based implementation of a Binary (Max) Heap.
Quiz:Based on this Binary (Max) Heap property, where will the largest integer be located?
Important fact to memorize at this point: If we have a Binary Heap ofNelements, its height will not be taller than O(logN) since we will store it as a complete binary tree.
Simple analysis: The sizeNof a full (more than just a complete) binary tree of heighthis alwaysN = 2(h+1)-1, thereforeh = log2(N+1)-1 ~= log2N.
See example above withN = 7 = 2(2+1)-1orh = log2(7+1)-1 = 2.
This fact is important in the analysis of all Binary Heap-related operations.
A complete binary tree can be stored efficiently as a compact array A as there is no gap between vertices of a complete binary tree/elements of a compact array. To simplify the navigation operations below, we use 1-based array. VisuAlgo displays the index of each vertex as ared labelbelow each vertex. Read those indices in sorted order from 1 toN, then you will see the vertices of the complete binary tree from top to down, left to right. To help you understand this,Toggle the Visualization Modeseveral times.
This way, we can implement basic binary tree traversal operations with simple index manipulations (with help ofbit shift manipulation):
parent(i) = i>>1, index i divided by 2 (integer division),
left(i) = i<<1, index i multiplied by 2,
right(i) = (i<<1)+1, index i multiplied by 2 and added by 1.
Pro tip: Try opening two copies of VisuAlgo on two browser windows. Try to visualize the same Binary Max Heap in two different modes and compare them.
In this visualization, you can perform several Binary (Max) Heap operations:
Create(A)- O(NlogN) version (Ncalls ofInsert(v)below)
Create(A)- O(N) version
Insert(v)in O(logN) — you are allowed to insert duplicates
3 versions ofExtractMax():Once, in O(logN)Ktimes, i.e.,PartialSort(), in O(KlogN), orNtimes, i.e.,HeapSort(), in O(NlogN)
Once, in O(logN)
Ktimes, i.e.,PartialSort(), in O(KlogN), or
Ntimes, i.e.,HeapSort(), in O(NlogN)
UpdateKey(i, newv)in O(logNifiis known)
Delete(i)in O(logNifiis known)
There are a few other possible Binary (Max) Heap operations, but currently we do not elaborate them for pedagogical reason in a certain NUS module.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Insert(v): Insertion of a new itemvinto a Binary Max Heap can only be done at thelast indexNplus 1to maintain the compact array = complete binary tree property. However, the Max Heap propertymaystill be violated. This operation then fixes Max Heap property from the insertion pointupwards(if necessary) and stop when there is no more Max Heap property violation. Now try clickingInsert(v)several times to insert a few randomvto the currently displayed Binary (Max Heap).
The fix Max Heap property upwards operation has no standard name. We call itShiftUpbut others may call itBubbleUporIncreaseKeyoperation.
Do you understand why starting from the insertion point (indexN+1) upwards (at most until the root) and swapping a vertex with its parent when there is a Max Heap property violation during insertion is always a correct strategy?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
The time complexity of thisInsert(v)operation is O(logN).
Discussion: Do you understand the derivation?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
ExtractMax(): The reporting and then the deletion of the maximum element (the root) of a Binary Max Heap requires an existing element to replace the root, otherwise the Binary Max Heap (a single complete binary tree, or 林/Lín in Chinese/tree) becomes two disjoint subtrees (two copies of 木/mù in Chinese/wood). That element must be thelast indexNfor the same reason: To maintain the compact array = complete binary tree property.
Because we promote a leaf vertex to the root vertex of a Binary Max Heap, it will very likely violates the Max Heap property. ExtractMax() operation then fixes Binary Max Heap property from the rootdownwardsby comparing the current value with the its child/the larger of its two children (if necessary). Now tryExtractMax()on the currently displayed Binary (Max) Heap.
The fix Max Heap property downwards operation has no standard name. We call itShiftDownbut others may call itBubbleDownorHeapifyoperation.
Why if a vertex has two children, we have to check (and possibly swap) that vertex withthe largerof its two children during the downwards fix of Max Heap property?
Why can't we just compare with the left (or right, if exists) vertex only?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
The time complexity of thisExtractMax()operation is O(logN).
Discussion: Do you understand the derivation?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
Up to here, we have a data structure that can implement the two major operations of Priority Queue (PQ) ADT efficiently:
ForEnqueue(x), we can useInsert(x)in O(logN) time, and
Fory= Dequeue(), we can usey = ExtractMax()in O(logN) time.
However, we can do a few more operations with Binary Heap.
Create(A): Creates a valid Binary (Max) Heap from an input arrayAofNintegers (comma separated) into an initially empty Binary Max Heap.
There are two variants for this operations, one that is simpler but runs in O(NlogN) and a more advanced technique that runs in O(N).
Pro tip: Try opening two copies of VisuAlgo on two browser windows. Execute different Create(A) versions on the worst case 'Sorted example' to see thesomewhat dramaticdifferences of the two.
Create(A) - O(N log N): Simply insert (that is, by callingInsert(v)operation) allNintegers of the input array into an initially empty Binary Max Heap one by one.
Analysis: This operation is clearly O(NlogN) as we call O(logN)Insert(v)operationNtimes. Let's examine the 'Sorted example' which is one of the hard case of this operation (Now try theHard Case - O(N log N)where we show a case whereA = [1,2,3,4,5,6,7]-- please be patient as this example will take some time to complete). If we insert values in increasing order into an initially empty Binary Max Heap, then every insertion triggers a path from the insertion point (a new leaf) upwards to the root.
Create(A) - O(N): This faster version ofCreate(A)operation was invented by Robert W. Floyd in 1964. It takes advantage of the fact that a compact array = complete binary tree and all leaves (i.e., half of the vertices — see the next slide) are Binary Max Heap by default. This operation then fixes Binary Max Heap property (if necessary) only from the last internal vertex back to the root.
Analysis: A loose analysis gives another O(N/2 logN) = O(NlogN) complexity but it is actually just O(2*N) = O(N) — detailshere. Now try theHard Case - O(N)on the same input arrayA = [1,2,3,4,5,6,7]and see that on the same hard case as with the previous slide (but not the one that generates maximum number of swaps — try 'Diagonal Entry' test case), this operation is far superior than the O(NlogN) version.
Simple explanation on why half of Binary (Max) Heap ofN(without loss of generality, let's assume thatNis even) elements are leaves are as follows:
Suppose that the last leaf is at indexN, then the parent of that last leaf is at indexi = N/2(rememberthis slide). The left child of vertexi+1, if exists (it actually does not exist), will be2*(i+1) = 2*(N/2+1) = N+2, which exceeds indexN(the last leaf) so indexi+1must also be a leaf vertex that has no child. As Binary Heap indexing is consecutive, basically indices [i+1 = N/2+1,i+2 = N/2+2, ...,N], or half of the vertices, are leaves.
HeapSort(): John William Joseph Williams inventedHeapSort()algorithm in 1964, together with this Binary Heap data structure.HeapSort()operation (assuming the Binary Max Heap has been created in O(N)) is very easy. Simply call the O(logN)ExtractMax()operationNtimes. Now tryHeapSort()on the currently displayed Binary (Max) Heap.
Simple Analysis:HeapSort()clearly runs in O(NlogN) — an optimal comparison-based sorting algorithm.
Quiz:In worst case scenario, HeapSort() is asymptotically faster than...
AlthoughHeapSort()runs in θ(NlogN) time for all (best/average/worst) cases, is it really the bestcomparison-basedsorting algorithm?
Discussion: How about caching performance ofHeapSort()?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
You have reached the end of the basic stuffs of this Binary (Max) Heap data structure and we encourage you to explore further in theExploration Mode.
However, we still have a few more interesting Binary (Max) Heap challenges for you that are outlined in this section.
When you have cleared them all, we invite you to study more advanced algorithms that use Priority Queue as (one of) its underlying data structure, likePrim's MST algorithm,Dijkstra's SSSP algorithm, A* search algorithm (not in VisuAlgo yet), a few other greedy-based algorithms, etc.
Earlier, we have seen that we can create Binary Max Heap from a random array of sizeNelements in O(N) instead of O(NlogN). Now, we will properly analyze this tighter bound.
First, we need to recall that the height of a full binary tree of sizeNis log2N.
Second, we need to realise that the cost to runshiftDown(i)operation is not the gross upper bound O(logN), but O(h) wherehis the height of the subtree rooted ati.
Third, there areceil(N/2h+1)vertices at heighthin a full binary tree.
On the example full binary tree above withN = 7andh = 2, there are:ceil(7/20+1) = 4vertices: {44,35,26,17} at heighth = 0,ceil(7/21+1) = 2vertices: {62,53} at heighth = 1, andceil(7/22+1) = 1vertex: {71} at heighth = 2.
Cost of Create(A), the O(N) version is thus:
PS: If the formula is too complicated, a modern student can also useWolframAlphainstead.
The faster O(N) Create Max Heap from a random array ofNelements is important for getting a faster solution if we only need topKelements out ofNitems, i.e.,PartialSort().
After O(N) Create Max Heap, we can then call the O(logN)ExtractMax()operationKtimes to get the topKlargest elements in the Binary (Max) Heap. Now tryPartialSort()on the currently displayed Binary (Max) Heap.
Analysis:PartialSort()clearly runs in O(N + KlogN) — an output-sensitive algorithm where the time complexity depends on the output sizeK. This is faster than thelower-bound of O(NlogN)if we fully sort the entireNelements whenK < N.
If we only deal with numbers (including this visualization that is restricted to integers only), it is easy to convert a Binary Max Heap into a Binary Min Heap without changing anything, or vice versa.
We can re-create a Binary Heap with the negation of every integer in the original Binary Heap. If we start with a Binary Max Heap, the resulting Binary Heap is a Binary Min Heap (if we ignore the negative symbols — see the picture above), and vice versa.
For some Priority Queue applications (e.g.,HeapDecreaseKey in Dijkstra's algorithm), we may have to modify (increase or decrease) the priority of an existing value that is already inserted into a Binary (Max) Heap. If the indexiof the value is known, we can do the following simple strategy: Simply updateA[i] = newvand then callbothshiftUp(i)andshiftDown(i). Only at most one of this Max Heap property restoration operation will be successful, i.e.,shiftUp(i)/shiftDown(i)will be triggered ifnewv>/< old value ofA[parent(i)]/A[larger of the two children of i], respectively.
Thus,UpdateKey(i, newv)can be done in O(logN), provided we know indexi.
For some Priority Queue applications, we may have to delete an existing value that is already inserted into a Binary (Max) Heap (and this value happens to be not the root). Again, if the indexiof the value is known, we can do the following simple strategy: Simply updateA[i] = A[1]+1(a larger number greater than the current root), callshiftUp(i)(technically,UpdateKey(i, A[1]+1)). This will floats indexito be the new root, and from there, we can easily callExtractMax()once to remove it.
Thus,Delete(i)can be done in O(logN), provided we know indexi.
Discussion: Now forUpdateKey(i, newv)andDelete(i), what if we are givenoldvinstead and thus we have to search for its location in the Binary (Max) Heap? Can we do this faster than O(N)?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
If there are duplicate keys, the standard implementation of Binary Heap as shown in this visualization does not guarantee stability. For example, if we insert three copies of {7, 7, 7}, e.g., {7a, 7b, and 7c} (suffix a, b, c are there only for clarity), in that order, into an initially empty Binary (Max) Heap. Then, upon first extraction, the root (7a) will be extracted first and the last existing leaf (7c) will replaces 7a. As 7c and 7b (without the suffixes) are equal (7 and 7), there is no swap happening and thus the second extract max will take out 7c instead of 7b first —not stable.
If we really need to guarantee stability of equal elements, we probably need to attach different suffixes as shown earlier to make those identical elements to be unique again.
If you are looking for an implementation of Binary (Max) Heap to actually model a Priority Queue, then there is a good news.
C++ and Java already have built-in Priority Queue implementations that very likely use this data structure. They areC++ STL priority_queue(the default is a Max Priority Queue) andJava PriorityQueue(the default is a Min Priority Queue). However, the built-in implementation may not be suitable to do some PQ extended operations efficiently (details omitted for pedagogical reason in a certain NUS course).
Pythonheapqexists but its performance is rather slow. OCaml doesn't have built-in Priority Queue but we can use something else that is going to be mentioned in the other modules in VisuAlgo (the reason on why the details are omitted is the same as above).
PS: Heap Sort is likely used in C++ STL algorithmpartial_sort.
Nevertheless, here is our implementation ofBinaryHeapDemo.cpp|py|java.
For a few more interesting questions about this data structure, please practice onBinary Heaptraining module (no login is required).
However, for NUS students, you should login using your official class account, officially clear this module, and such achievement will be recorded in your user account.
We also have a few programming problems that somewhat requires the usage of this Binary Heap data structure:UVa 01203 - ArgusandKattis - numbertree.
Try them to consolidate and improve your understanding about this data structure. You are allowed to use C++ STL priority_queue, Python heapq, or Java PriorityQueue if that simplifies your implementation.
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
After spending one long lecture on Binary (Max) Heap, here is a jaw-dropping moment...
Binary (Max) Heap data structure is probablynotthe best data structure to implement (certain operations of) ADT Priority Queue...
Discussion: So what is the alternative data structure?
The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the variousflipped classroomsin NUS.
If you are really a CS lecturer (or an IT teacher)(outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (show your University staff profile/relevant proof to Steven) for Steven to manually activate this CS lecturer-only feature for you.
FAQ: This feature willNOTbe given to anyone else who is not a CS lecturer.
You have reached the last slide. Return to 'Exploration Mode' to start exploring!
Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.
-> Compact Array Mode
Create(A) - O(NlogN)
Create(A) - O(N)
Insert(v)
ExtractMax()
HeapSort()
UpdateKey(i, newv)
Delete(i)
Go
Best Case: Sorted Descending
Random
Worst Case: Sorted Ascending
Go
Best Case: Sorted Descending
Random
Worst Case: Diagonal Entry
Go
1x (Once)
Kx (PartialSort)
Go
Default
In-place
Go
Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.
Featuring numerous advanced algorithms discussed in Dr. Steven Halim's book, 'Competitive Programming' — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.
While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.
Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.
VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.
Equipped with a built-in question generator and answer verifier, VisuAlgo's "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students' answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students' mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.
VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:
Project Leader & Advisor (Jul 2011-present)Associate Professor Steven Halim,  School of Computing (SoC), National University of Singapore (NUS)Dr Felix Halim, Senior Software Engineer, Google (Mountain View)
Undergraduate Student Researchers 1CDTL TEG 1: Jul 2011-Apr 2012: Koh Zi Chun, Victor Loh Bo Huai
Final Year Project/UROP students 1Jul 2012-Dec 2013: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang DuyJun 2013-Apr 2014Rose Marie Tan Zhao Yun, Ivan Reinaldo
Undergraduate Student Researchers 2CDTL TEG 2: May 2014-Jul 2014: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
Final Year Project/UROP students 2Jun 2014-Apr 2015: Erin Teo Yi Ling, Wang ZiJun 2016-Dec 2017: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin MudzakirAug 2021-Apr 2023: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius
Undergraduate Student Researchers 3Optiver: Aug 2023-Oct 2023: Bui Hong Duc, Oleh Naver, Tay Ngan Lin
Final Year Project/UROP students 3Aug 2023-Apr 2024: Xiong Jingya, Radian Krisno, Ng Wee Han, Tan Chee HengAug 2024-Apr 2025: Edbert Geraldy Cangdinata, Huang Xing Chen, Nicholas Patrick
List of translators who have contributed ≥ 100 translations can be found atstatisticspage.
AcknowledgementsNUSCDTLgave Teaching Enhancement Grant to kickstart this project.For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.
VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that youspread the word about its existence to fellow Computer Science students and instructors. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.
Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (https://visualgo.net) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo's client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.
Please note that VisuAlgo's online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the 'training mode.' The 'test mode' offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.
List of Publications
This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can clickthis linkto read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) andthis linkfor the short update in 2015 (to link VisuAlgo name with the previous project).
Bug Reports or Request for New Features
VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.
Version 1.2 (Updated Fri, 18 Aug 2023).
Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.
Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).
Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.
For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.
For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.